<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Short Vowel Word Ladders</title>

  <script src="blendsmaster.js" defer></script>

  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">

  <style>
    @font-face {
      font-family: 'BoxesFont';
      src: url('fonts/boxes2.otf') format('opentype');
    }
    @font-face {
      font-family: 'UnderlineFont';
      src: url('fonts/underlines.otf') format('opentype');
    }

    :root{
      --ink:#1f365f;
      --bg:#ffffff;
      --card:#f6f9ff;
      --card2:#fff7f0;
      --border:#cfd7ef;
      --border2:#f2d8bd;
    }

    body {
      font-family: 'Poppins', sans-serif;
      margin: 10px;
      text-align: center;
      color: var(--ink);
      background: var(--bg);
    }

    h1 { font-size: 32px; margin-bottom: 6px; }
    .subtitle { font-size: 16px; margin-bottom: 8px; }

    button { font-size: 16px; padding: 6px 10px; margin: 6px; cursor: pointer; }
    label { margin: 0 6px; font-size: 18px; }

    .pattern {
      font-size: 100px;
      line-height: 1;
      margin-top: 4px;
    }

    #copyright {
      font-size: 12px;
      text-align: right;
      width: 100%;
    }

    .groupTitle {
      font-weight: 600;
      margin-top: 6px;
    }

    /* Cards (centered, light background, bigger text) */
    .card {
      display: inline-block;
      text-align: center;
      background: var(--card);
      border: 2px solid var(--border);
      border-radius: 14px;
      padding: 14px 18px;
      margin: 10px auto;
      font-size: 18px;
    }
    .card.alt {
      background: var(--card2);
      border-color: var(--border2);
    }
    .card h2 {
      margin: 0 0 8px;
      font-size: 20px;
    }
    .controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
      font-size: 18px;
    }

    /* Teacher-only directions (don’t print) */
    .screenOnly { display: block; font-size: 18px; }
    @media print {
      body * { visibility: hidden; }
      #ladderOutput, #ladderOutput * { visibility: visible; }
      #ladderOutput {
        position: absolute;
        top: 0; left: 0;
        width: 100%;
        margin: 0; padding: 10px;
        box-sizing: border-box;
      }
      .screenOnly { display: none !important; }
      #ladderOutput br { display: none !important; }
      @page { margin: 0.5in; }
    }
  </style>
</head>
<body>

  <h1>Short Vowel Word Ladders</h1>

  <!-- Teacher directions (screen only, not printed) -->
  <div class="screenOnly" style="max-width:920px;margin:0 auto 12px;">
    <strong>Directions:</strong>
    Generate a Short Vowel Ladder in seconds. Select if you want
    <em>CVC</em> (e.g., <strong>bat → hat</strong>),
    <em>Blends included</em> (e.g., <strong>pan → pant</strong>), or
    <em>Blends Only</em> (e.g., <strong>send → bend</strong>).
  </div>

  <!-- FORMAT (Mode) -->
  <div class="card">
    <h2>Format</h2>
    <div class="controls">
      <label><input type="radio" name="ladderMode" value="CVC" checked> 1. CVC</label>
      <label><input type="radio" name="ladderMode" value="Include Blends"> 2. Include Blends</label>
      <label><input type="radio" name="ladderMode" value="Only Blends"> 3. Only Blends</label>
    </div>
  </div>

  <!-- DISPLAY -->
  <div class="card alt">
    <h2>Display</h2>
    <div class="controls">
      <label><input type="radio" name="cellStyle" value="elkonin" checked> Elkonin Boxes</label>
      <label><input type="radio" name="cellStyle" value="underlines"> Underlines</label>
      <label><input type="checkbox" id="boldChanged" checked> Bold Changed Part</label>
    </div>
  </div>

  <!-- ACTIONS -->
  <div style="margin: 8px 0 10px;">
     <center><img src="images/chrome.png"></center>
    <button onclick="generateLadder()">Generate Ladder</button>
    <button onclick="window.print()">Print Page</button>
  </div>

  <div id="ladderOutput" style="margin-top:8px; margin-bottom:60px;"></div>

  <script>
  function splitWordByPattern(word, pattern) {
    const chunks = [];
    let i = 0;
    for (let j = 0; j < pattern.length; j++) {
      const d = pattern[j];
      const len = d === '3' ? 3 : (d === '2' ? 2 : 1);
      chunks.push(word.slice(i, i + len));
      i += len;
    }
    return chunks;
  }

  // New: per-letter (unit-level) change map
  function getUnitChangeMap(prevWord, word, prevPattern, pattern) {
    const prevChunks = splitWordByPattern(prevWord, prevPattern);
    const curChunks  = splitWordByPattern(word, pattern);

    function pushMany(arr, n, v){ for (let i=0;i<n;i++) arr.push(v); }

    const maxChunks = Math.max(prevChunks.length, curChunks.length);
    const unitChanges = [];

    for (let i = 0; i < maxChunks; i++) {
      const a = prevChunks[i] || '';
      const b = curChunks[i]  || '';
      const aLen = a.length, bLen = b.length;

      if (!bLen) continue;

      if (a === b) { pushMany(unitChanges, bLen, false); continue; }

      if (bLen === aLen + 1 && (b.startsWith(a) || b.endsWith(a))) {
        if (b.startsWith(a)) { pushMany(unitChanges, aLen, false); unitChanges.push(true); }
        else { unitChanges.push(true); pushMany(unitChanges, aLen, false); }
        continue;
      }

      if (aLen === bLen) {
        for (let k = 0; k < bLen; k++) unitChanges.push(a[k] !== b[k]);
        continue;
      }

      pushMany(unitChanges, bLen, true);
    }

    return unitChanges;
  }

  // New: render pattern per unit so we can bold only changed letters
  function renderPatternHTMLUnits(pattern, useFont, boldUnits) {
    const isUnderline = useFont === 'UnderlineFont';
    const lens = Array.from(pattern).map(d => d === '3' ? 3 : (d === '2' ? 2 : 1));

    let html = '';
    let unitIndex = 0;

    for (let c = 0; c < lens.length; c++) {
      const L = lens[c];
      html += `<span style="${isUnderline ? 'display:inline-block;margin:0 6px;' : ''}">`;
      for (let u = 0; u < L; u++) {
        const bold = boldUnits && !!boldUnits[unitIndex];
        html += `<span style="${bold ? 'font-weight:700;' : ''}">1</span>`;
        unitIndex++;
      }
      html += `</span>`;
    }
    return html;
  }

  // Existing getChunkHint unchanged
  function getChunkHint(prevWord, word, prevPattern, pattern) {
    const prevChunks = splitWordByPattern(prevWord, prevPattern);
    const wordChunks = splitWordByPattern(word, pattern);

    const arraysEqual = (a, b) => a.length === b.length && a.every((v,i)=>v===b[i]);

    if (prevChunks.length === wordChunks.length) {
      let idx = -1;
      for (let i = 0; i < prevChunks.length; i++) {
        if (prevChunks[i] !== wordChunks[i]) {
          if (idx !== -1) return '? → ?';
          idx = i;
        }
      }
      if (idx === -1) return '? → ?';

      const a = prevChunks[idx];
      const b = wordChunks[idx];

      if (b.length === a.length + 1 && (b.startsWith(a) || b.endsWith(a))) {
        const added = b.startsWith(a) ? b.slice(-1) : b.slice(0, b.length - a.length);
        const micro = b.startsWith(a)
          ? `${a} → ${a}<b>${added}</b>`
          : `${a} → <b>${added}</b>${a}`;
        return `+ ${added} <span style="font-size:16px;opacity:.8;margin-left:8px;">${micro}</span>`;
      }

      if (a.length === b.length + 1 && (a.startsWith(b) || a.endsWith(b))) {
        const removed = a.startsWith(b) ? a.slice(-1) : a.slice(0, a.length - b.length);
        const micro = a.startsWith(b)
          ? `${a.slice(0, -1)}<b>${removed}</b> → ${b}`
          : `<b>${removed}</b>${a.slice(1)} → ${b}`;
        return `- ${removed} <span style="font-size:16px;opacity:.8;margin-left:8px;">${micro}</span>`;
      }

      return `${a} → ${b}`;
    }

    if (wordChunks.length === prevChunks.length + 1) {
      for (let k = 0; k < wordChunks.length; k++) {
        const test = wordChunks.slice(0, k).concat(wordChunks.slice(k + 1));
        if (arraysEqual(prevChunks, test)) return `+ ${wordChunks[k]}`;
      }
      return '? → ?';
    }

    if (prevChunks.length === wordChunks.length + 1) {
      for (let k = 0; k < prevChunks.length; k++) {
        const test = prevChunks.slice(0, k).concat(prevChunks.slice(k + 1));
        if (arraysEqual(wordChunks, test)) return `- ${prevChunks[k]}`;
      }
      return '? → ?';
    }

    return '? → ?';
  }

  function generateLadder() {
    if (typeof getLaddersByMode !== 'function' || typeof rWordPatterns === 'undefined' || typeof rWordImages === 'undefined') {
      alert('❌ Error: Data not loaded. Check blendsmaster.js');
      return;
    }

    const cellStyle = document.querySelector('input[name="cellStyle"]:checked').value;
    const useFont = cellStyle === 'underlines' ? 'UnderlineFont' : 'BoxesFont';
    const boldChanged = document.getElementById('boldChanged').checked;

    const mode = document.querySelector('input[name="ladderMode"]:checked').value;
    const ladders = getLaddersByMode(mode);
    if (!ladders || !Array.isArray(ladders) || ladders.length === 0) {
      alert('❌ No ladders available for this mode.');
      return;
    }

    const randomIndex = Math.floor(Math.random() * ladders.length);
    const ladder = ladders[randomIndex];

    const rowsHTML = ladder.map((word, idx) => {
      const isFirst = idx === 0;
      const isLast = idx === ladder.length - 1;
      const prevWord = ladder[idx - 1] || '';

      const pattern = rWordPatterns[word] || '?';
      const prevPattern = rWordPatterns[prevWord] || '?';

      const boldUnits = (!isFirst && boldChanged) ? getUnitChangeMap(prevWord, word, prevPattern, pattern) : null;

      const patternHTML = isFirst ? '' : renderPatternHTMLUnits(pattern, useFont, boldUnits);

      const wordDisplay = isFirst
        ? `<div style="font-size:32px;font-weight:600;letter-spacing:2px;font-family:'Poppins', sans-serif;">${word}</div>`
        : `<div class="pattern" style="
             font-family:'${useFont}', monospace;
             font-size:${useFont === 'UnderlineFont' ? '85px' : '100px'};
             letter-spacing:0px;
           ">${patternHTML}</div>`;

      const imgSrc = rWordImages[word] || 'https://via.placeholder.com/110?text=?';

      const imageTD = `<td style="padding:5px 7px;width:140px;">
                         <img src="${imgSrc}" alt="${word}" style="width:110px;height:110px;object-fit:contain;">
                       </td>`;

      const borders = !isLast
        ? 'border-bottom:4px solid #000;border-left:4px solid #000;border-right:4px solid #000;'
        : 'border-left:4px solid #000;border-right:4px solid #000;';

      const wordTD = `<td style="padding:5px 7px;${borders}">${wordDisplay}</td>`;

      const hintTD = (() => {
        if (isFirst) return `<td style="padding:3px 5px;width:170px;"></td>`;
        const hint = getChunkHint(prevWord, word, prevPattern, pattern);
        return `<td style="padding:3px 5px;width:170px;">
                  <div style="
                    display:flex;justify-content:center;align-items:center;
                    background:#f0f0f0;border:3px solid #000;border-radius:12px;
                    padding:6px 10px;font-size:22px;text-align:center;
                  ">${hint}</div>
                </td>`;
      })();

      return `<tr>${imageTD}${wordTD}${hintTD}</tr>`;
    }).join('');

    const ladderHTML = `
      <div style="display:flex;flex-direction:column;align-items:center;width:98%;margin:0 auto;">
        <div id="titleBlock" style="text-align:center;">
          <h2 style="font-size:24px;">Short Vowel Word Ladders</h2>
          <p style="font-size:12px;"><strong>Directions:</strong> Start at the top of the ladder and spell the correct words.</p>
        </div>
        <table style="border-collapse:collapse;margin:0 auto;width:100%;max-width:600px;">
          ${rowsHTML}
        </table>
        <br><br>
        <div id="copyright">Copyright - InterventionStation.com - @TeachwithMrC</div>
      </div>
    `;

    document.getElementById('ladderOutput').innerHTML = ladderHTML;
  }
  </script>
</body>
</html>
