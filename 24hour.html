<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>24-Hour Circle Planner</title>
  <style>
    :root{
      --ink:#000; --bg:#fff;
      --stroke:3.25; --strokeThin:2;
      --font: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    body{ margin:0; background:var(--bg); color:var(--ink); font-family:var(--font); }
    .wrap{ max-width:1150px; margin:0 auto; padding:18px; display:grid; grid-template-columns:1fr 1.25fr; gap:18px; }
    h1{ margin:0 0 10px; font-size:22px; font-weight:950; }
    .card{ border:var(--strokeThin) solid var(--ink); border-radius:14px; padding:14px; }
    .hint{ font-size:13px; font-weight:800; line-height:1.35; margin:0 0 12px; opacity:.95; }
    .stage{ border:var(--strokeThin) solid var(--ink); border-radius:14px; padding:10px; background:#fff; }
    .stage svg{ width:100%; height:auto; display:block; }

    .topControls{ display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:12px; }
    label{ font-weight:950; display:block; margin:0 0 6px; }
    input, select{
      width:100%; box-sizing:border-box;
      font-size:14px; font-weight:900;
      border:var(--strokeThin) solid var(--ink);
      border-radius:10px; padding:8px 10px; background:#fff; outline:none;
    }

    .toggleRow{ display:flex; gap:14px; flex-wrap:wrap; margin:8px 0 14px; }
    .toggleRow label{ margin:0; font-size:13px; font-weight:950; display:flex; align-items:center; gap:8px; }
    .toggleRow input{ width:auto; }

    .blocks{ display:flex; flex-direction:column; gap:10px; }
    .block{
      border:var(--strokeThin) solid var(--ink);
      border-radius:14px;
      padding:10px;
    }
    .blockHead{
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      margin-bottom:8px;
    }
    .blockTitle{ font-weight:950; }
    .removeBtn{
      border:var(--strokeThin) solid var(--ink);
      background:#fff; border-radius:10px;
      font-weight:950; padding:6px 10px; cursor:pointer;
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .timeGrid{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:8px;
    }

    .btnRow{ display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; }
    button{
      font-family:var(--font);
      font-weight:950;
      border:var(--strokeThin) solid var(--ink);
      background:#fff;
      border-radius:12px;
      padding:10px 12px;
      cursor:pointer;
    }
    button:active{ transform:translateY(1px); }

    @media print{
      .wrap{ grid-template-columns:1fr; padding:0; }
      .card{ display:none; }
      .stage{ border:none; padding:0; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>24-Hour Circle Planner</h1>
      <p class="hint">
        Add a <b>Schedule Block</b> (example: 12:00 AM → 5:00 AM “Sleep”). Each block shades + repeats the label so it looks filled.
      </p>

      <div class="topControls">
        <div>
          <label>Intervals</label>
          <select id="slotMode">
            <option value="30" selected>30 minutes</option>
            <option value="60">60 minutes</option>
            <option value="15">15 minutes</option>
          </select>
        </div>
        <div>
          <label>Text size</label>
          <input id="fontSize" type="number" min="8" max="18" value="12" />
        </div>
      </div>

      <div class="toggleRow">
        <label><input type="checkbox" id="shadeBlocks" checked> Shade blocks</label>
        <label><input type="checkbox" id="repeatText" checked> Repeat label in each slot</label>
      </div>

      <div class="blocks" id="blocks"></div>

      <div class="btnRow">
        <button id="addBlockBtn">Add Schedule Block</button>
        <button id="printBtn">Print</button>
        <button id="downloadBtn">Download SVG</button>
        <button id="clearBtn">Clear All</button>
      </div>
    </div>

    <div class="stage">
      <svg id="svg" viewBox="0 0 900 1250" xmlns="http://www.w3.org/2000/svg" aria-label="Circle planner"></svg>
    </div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const svg = $("svg");
  const blocksWrap = $("blocks");

  const slotModeEl = $("slotMode");
  const fontSizeEl = $("fontSize");
  const shadeBlocksEl = $("shadeBlocks");
  const repeatTextEl = $("repeatText");

  const state = {
    blocks: [] // { id, startH, startM, startMer, endH, endM, endMer, label }
  };

  $("addBlockBtn").addEventListener("click", () => {
    addBlock();
    renderUI();
    renderPlanner();
  });

  $("clearBtn").addEventListener("click", () => {
    state.blocks = [];
    addBlock(); // leave one blank block
    renderUI();
    renderPlanner();
  });

  $("printBtn").addEventListener("click", () => window.print());
  $("downloadBtn").addEventListener("click", downloadSVG);

  [slotModeEl, fontSizeEl, shadeBlocksEl, repeatTextEl].forEach(el => {
    el.addEventListener("change", renderPlanner);
    el.addEventListener("input", renderPlanner);
  });

  function addBlock(prefill = null) {
    const id = crypto.randomUUID ? crypto.randomUUID() : String(Date.now() + Math.random());
    state.blocks.push({
      id,
      startH: prefill?.startH ?? "12",
      startM: prefill?.startM ?? "00",
      startMer: prefill?.startMer ?? "AM",
      endH: prefill?.endH ?? "1",
      endM: prefill?.endM ?? "00",
      endMer: prefill?.endMer ?? "AM",
      label: prefill?.label ?? ""
    });
  }

  function hours12() { return Array.from({length:12},(_,i)=>String(i+1)); }
  function minutesList() { return ["00","15","30","45"]; }

  function renderUI() {
    blocksWrap.innerHTML = "";

    state.blocks.forEach((b, idx) => {
      const block = document.createElement("div");
      block.className = "block";

      block.innerHTML = `
        <div class="blockHead">
          <div class="blockTitle">Schedule Block ${idx + 1}</div>
          <button class="removeBtn" ${state.blocks.length===1 ? "disabled" : ""}>Remove</button>
        </div>

        <div class="grid">
          <div>
            <label>Start</label>
            <div class="timeGrid">
              <select data-k="startH"></select>
              <select data-k="startM"></select>
              <select data-k="startMer">
                <option>AM</option><option>PM</option>
              </select>
            </div>
          </div>

          <div>
            <label>End</label>
            <div class="timeGrid">
              <select data-k="endH"></select>
              <select data-k="endM"></select>
              <select data-k="endMer">
                <option>AM</option><option>PM</option>
              </select>
            </div>
          </div>
        </div>

        <div style="margin-top:10px;">
          <label>Event</label>
          <input data-k="label" placeholder="Sleep, Appointment, Work..." />
        </div>
      `;

      // populate selects
      const selStartH = block.querySelector('select[data-k="startH"]');
      const selStartM = block.querySelector('select[data-k="startM"]');
      const selStartMer = block.querySelector('select[data-k="startMer"]');

      const selEndH = block.querySelector('select[data-k="endH"]');
      const selEndM = block.querySelector('select[data-k="endM"]');
      const selEndMer = block.querySelector('select[data-k="endMer"]');

      fillSelect(selStartH, hours12(), b.startH);
      fillSelect(selStartM, minutesList(), b.startM);
      selStartMer.value = b.startMer;

      fillSelect(selEndH, hours12(), b.endH);
      fillSelect(selEndM, minutesList(), b.endM);
      selEndMer.value = b.endMer;

      const labelInput = block.querySelector('input[data-k="label"]');
      labelInput.value = b.label;

      // listeners -> update state -> render planner
      const wire = (el, key) => {
        el.addEventListener("change", () => { b[key] = el.value; maybeAutoAddNext(idx); renderPlanner(); });
        el.addEventListener("input",  () => { b[key] = el.value; maybeAutoAddNext(idx); renderPlanner(); });
      };
      wire(selStartH, "startH"); wire(selStartM, "startM"); wire(selStartMer, "startMer");
      wire(selEndH, "endH");     wire(selEndM, "endM");     wire(selEndMer, "endMer");
      wire(labelInput, "label");

      // remove
      const removeBtn = block.querySelector(".removeBtn");
      removeBtn.addEventListener("click", () => {
        if (state.blocks.length === 1) return;
        state.blocks = state.blocks.filter(x => x.id !== b.id);
        renderUI();
        renderPlanner();
      });

      blocksWrap.appendChild(block);
    });
  }

  function maybeAutoAddNext(idx) {
    // If they typed a label in the last block, automatically add a new blank block.
    const isLast = idx === state.blocks.length - 1;
    if (!isLast) return;

    const b = state.blocks[idx];
    const hasAny = (b.label || "").trim().length > 0;
    if (hasAny) {
      // only add if there isn't already an extra blank block
      // (i.e., last block is no longer blank)
      addBlock();
      renderUI();
    }
  }

  function fillSelect(el, items, selected){
    el.innerHTML = "";
    for (const it of items) {
      const opt = document.createElement("option");
      opt.value = it;
      opt.textContent = it;
      if (String(it) === String(selected)) opt.selected = true;
      el.appendChild(opt);
    }
  }

  // ----- Planner rendering -----
  function toMinutes12h(hourStr, minStr, mer) {
    let h = parseInt(hourStr,10) % 12;
    const m = parseInt(minStr,10);
    if (mer === "PM") h += 12;
    return h*60 + m; // 0..1439
  }

  function renderPlanner(){
    const slotMinutes = parseInt(slotModeEl.value,10) || 30;
    const fontSize = clamp(parseInt(fontSizeEl.value,10) || 12, 8, 18);
    fontSizeEl.value = fontSize;

    const shadeMode = shadeBlocksEl.checked;
    const repeatMode = repeatTextEl.checked;

    // Build events list from blocks that have a label
    const events = [];
    for (const b of state.blocks){
      const label = (b.label || "").trim();
      if (!label) continue;

      const start = toMinutes12h(b.startH, b.startM, b.startMer);
      let end = toMinutes12h(b.endH, b.endM, b.endMer);
      if (end <= start) end += 24*60; // crosses midnight
      events.push({ start, end, label });
    }

    // clear svg
    while (svg.firstChild) svg.removeChild(svg.firstChild);

    // stacked circles
    const cx = 450, cyAM = 380, cyPM = 920;
    const R = 290, ringWidth = 95, innerR = R - ringWidth;

    addText(cx, 55, "TIME TABLE", 26, 950, "middle");
    drawClockFace(cx, cyAM, R, innerR, "AM", slotMinutes);
    drawClockFace(cx, cyPM, R, innerR, "PM", slotMinutes);

    for (const ev of events){
      drawEventOnWindow(ev, cx, cyAM, R, innerR, 0, 12*60, slotMinutes, fontSize, repeatMode, shadeMode);
      drawEventOnWindow(ev, cx, cyPM, R, innerR, 12*60, 24*60, slotMinutes, fontSize, repeatMode, shadeMode);
    }

    // ---- helpers ----
    function drawEventOnWindow(ev, cx, cy, R, innerR, winStart, winEnd, slotMin, fontSize, repeatMode, shadeMode){
      // render only within today's 0..1440 range
      const s0 = clamp(ev.start, 0, 24*60);
      const e0 = clamp(ev.end,   0, 24*60);
      const start = Math.max(s0, winStart);
      const end   = Math.min(e0, winEnd);
      if (end <= start) return;

      const slots = Math.round((12*60)/slotMin);
      const aSlot = Math.floor((start - winStart) / slotMin);
      const bSlot = Math.ceil((end - winStart) / slotMin);

      if (shadeMode){
        for (let i=aSlot; i<bSlot; i++){
          shadeWedge(cx, cy, innerR, R, slotToAngle(i, slots), slotToAngle(i+1, slots), 0.14);
        }
      }

      if (repeatMode){
        for (let i=aSlot; i<bSlot; i++){
          placeLabel(ev.label, i + 0.5, slots, cx, cy, (R+innerR)/2, fontSize);
        }
      } else {
        placeLabel(ev.label, (aSlot + bSlot)/2, slots, cx, cy, (R+innerR)/2, fontSize);
      }
    }

    function shadeWedge(cx, cy, r0, r1, a0, a1, opacity){
      const p0o = polar(cx,cy,r1,a0);
      const p1o = polar(cx,cy,r1,a1);
      const p1i = polar(cx,cy,r0,a1);
      const p0i = polar(cx,cy,r0,a0);
      const largeArc = (a1 - a0) > Math.PI ? 1 : 0;

      const d = [
        `M ${p0o.x} ${p0o.y}`,
        `A ${r1} ${r1} 0 ${largeArc} 1 ${p1o.x} ${p1o.y}`,
        `L ${p1i.x} ${p1i.y}`,
        `A ${r0} ${r0} 0 ${largeArc} 0 ${p0i.x} ${p0i.y}`,
        "Z"
      ].join(" ");

      const path = document.createElementNS("http://www.w3.org/2000/svg","path");
      path.setAttribute("d", d);
      path.setAttribute("fill", "black");
      path.setAttribute("fill-opacity", String(opacity));
      svg.appendChild(path);
    }

    function placeLabel(text, slotMid, slots, cx, cy, rText, fontSize){
      const clean = (text || "").trim();
      if (!clean) return;

      const ang = slotToAngle(slotMid, slots);
      const p = polar(cx,cy,rText,ang);

      const deg = ang * 180/Math.PI;
      let rot = deg + 90;
      if (deg > 90 && deg < 270) rot += 180;

      const lines = wrapText(clean, 14).slice(0,3);

      const t = document.createElementNS("http://www.w3.org/2000/svg","text");
      t.setAttribute("x", p.x);
      t.setAttribute("y", p.y);
      t.setAttribute("fill","black");
      t.setAttribute("font-family","system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif");
      t.setAttribute("font-size", String(fontSize));
      t.setAttribute("font-weight","950");
      t.setAttribute("text-anchor","middle");
      t.setAttribute("dominant-baseline","middle");
      t.setAttribute("transform", `rotate(${rot} ${p.x} ${p.y})`);
      svg.appendChild(t);

      lines.forEach((ln, i) => {
        const sp = document.createElementNS("http://www.w3.org/2000/svg","tspan");
        sp.setAttribute("x", p.x);
        sp.setAttribute("dy", i===0 ? "0" : String(fontSize + 2));
        sp.textContent = ln;
        t.appendChild(sp);
      });
    }

    function drawClockFace(cx,cy,R,innerR,tag,slotMinutes){
      addCircle(cx,cy,R, 3.25);
      addCircle(cx,cy,innerR, 3.25);
      addText(cx, cy + R + 44, tag, 22, 950, "middle");

      const slots = Math.round((12*60)/slotMinutes);
      const majorEvery = Math.max(1, Math.round(60/slotMinutes));

      for (let i=0; i<slots; i++){
        const ang = slotToAngle(i, slots);
        const p1 = polar(cx,cy,innerR, ang);
        const p2 = polar(cx,cy,R, ang);
        addLine(p1.x,p1.y,p2.x,p2.y, (i % majorEvery === 0) ? 3.25 : 2.0);
      }

      for (let h=0; h<12; h++){
        const label = (h===0) ? "12" : String(h);
        const ang = hourToAngle(h);
        const p = polar(cx,cy,R+26, ang);
        addText(p.x, p.y, label, 20, 950, "middle");
      }
    }

    function addText(x,y,txt,size,weight,anchor="start"){
      const t = document.createElementNS("http://www.w3.org/2000/svg","text");
      t.setAttribute("x", x);
      t.setAttribute("y", y);
      t.setAttribute("fill", "black");
      t.setAttribute("font-family", "system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif");
      t.setAttribute("font-size", String(size));
      t.setAttribute("font-weight", String(weight));
      t.setAttribute("text-anchor", anchor);
      t.setAttribute("dominant-baseline", "middle");
      t.textContent = txt;
      svg.appendChild(t);
      return t;
    }
    function addLine(x1,y1,x2,y2,sw){
      const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
      ln.setAttribute("x1", x1); ln.setAttribute("y1", y1);
      ln.setAttribute("x2", x2); ln.setAttribute("y2", y2);
      ln.setAttribute("stroke", "black");
      ln.setAttribute("stroke-width", String(sw));
      ln.setAttribute("stroke-linecap","round");
      svg.appendChild(ln);
      return ln;
    }
    function addCircle(x,y,r,sw){
      const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute("cx", x); c.setAttribute("cy", y); c.setAttribute("r", r);
      c.setAttribute("fill","none");
      c.setAttribute("stroke","black");
      c.setAttribute("stroke-width", String(sw));
      svg.appendChild(c);
      return c;
    }
    function hourToAngle(h){ return (-Math.PI/2) + (h * (2*Math.PI/12)); }
    function slotToAngle(i, slots){ return (-Math.PI/2) + (i * (2*Math.PI/slots)); }
    function polar(cx,cy,r,ang){ return { x: cx + r*Math.cos(ang), y: cy + r*Math.sin(ang) }; }
    function wrapText(str, maxChars){
      const words = str.split(/\s+/).filter(Boolean);
      const out = [];
      let cur = "";
      for (const w of words){
        const next = cur ? (cur + " " + w) : w;
        if (next.length <= maxChars) cur = next;
        else { if (cur) out.push(cur); cur = w.length>maxChars ? w.slice(0,maxChars-1)+"…" : w; }
      }
      if (cur) out.push(cur);
      return out;
    }
    function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
  }

  function downloadSVG(){
    const xml = new XMLSerializer().serializeToString(svg);
    const blob = new Blob([xml], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "circle-time-planner.svg";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // Start with one block, like you described
  addBlock({ startH:"12", startM:"00", startMer:"AM", endH:"5", endM:"00", endMer:"AM", label:"Sleep" });
  addBlock(); // also start with block 2 ready (since you said could already be there)
  renderUI();
  renderPlanner();
})();
</script>
</body>
</html>
