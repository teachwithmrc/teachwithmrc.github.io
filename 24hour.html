<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>24-Hour Circle Planner</title>
  <style>
    :root{
      --ink:#000; --bg:#fff;
      --stroke:3.25; --strokeThin:2;
      --font: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    body{ margin:0; background:var(--bg); color:var(--ink); font-family:var(--font); }
    .wrap{ max-width:1150px; margin:0 auto; padding:18px; display:grid; grid-template-columns:1fr 1.25fr; gap:18px; }
    h1{ margin:0 0 10px; font-size:22px; font-weight:950; }
    .card{ border:var(--strokeThin) solid var(--ink); border-radius:14px; padding:14px; }
    .hint{ font-size:13px; font-weight:750; line-height:1.35; margin:0 0 12px; opacity:.95; }

    .stage{
      border:var(--strokeThin) solid var(--ink);
      border-radius:14px;
      padding:10px;
      background:#fff;
      overflow:hidden;
    }
    /* Lock a predictable render size so circles never collide */
    .stage svg{
      width:100%;
      height:auto;
      display:block;
    }

    .topControls{ display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:12px; }
    label{ font-weight:900; display:block; margin:0 0 6px; }

    /* IMPORTANT: don’t over-bold selects; make them readable on Safari */
    input, select{
      width:100%;
      box-sizing:border-box;
      font-size:14px;
      font-weight:700;            /* was 900+ */
      color:#000;                 /* force visible text */
      background-color:#fff;      /* force visible selection */
      border:var(--strokeThin) solid var(--ink);
      border-radius:10px;
      padding:8px 10px;
      outline:none;
      appearance:auto;
      -webkit-appearance: menulist;  /* Safari */
      -moz-appearance: auto;
    }
    input::placeholder{ color: rgba(0,0,0,.55); font-weight:650; }

    .toggleRow{ display:flex; gap:14px; flex-wrap:wrap; margin:8px 0 14px; }
    .toggleRow label{ margin:0; font-size:13px; font-weight:900; display:flex; align-items:center; gap:8px; }
    .toggleRow input{ width:auto; }

    .blocks{ display:flex; flex-direction:column; gap:10px; }
    .block{
      border:var(--strokeThin) solid var(--ink);
      border-radius:14px;
      padding:10px;
    }
    .blockHead{ display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:8px; }
    .blockTitle{ font-weight:950; }
    .removeBtn{
      border:var(--strokeThin) solid var(--ink);
      background:#fff;
      border-radius:10px;
      font-weight:900;
      padding:6px 10px;
      cursor:pointer;
    }
    .grid{ display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    .timeGrid{ display:grid; grid-template-columns:1fr 1fr 1fr; gap:8px; }

    .btnRow{ display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; }
    button{
      font-family:var(--font);
      font-weight:950;
      border:var(--strokeThin) solid var(--ink);
      background:#fff;
      border-radius:12px;
      padding:10px 12px;
      cursor:pointer;
    }
    button:active{ transform:translateY(1px); }

    @media print{
      .wrap{ grid-template-columns:1fr; padding:0; }
      .card{ display:none; }
      .stage{ border:none; padding:0; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>24-Hour Circle Planner</h1>
      <p class="hint">
        Add <b>Schedule Blocks</b>. The circles are stacked (AM on top, PM below). Selections should now show correctly.
      </p>

      <div class="topControls">
        <div>
          <label>Intervals</label>
          <select id="slotMode">
            <option value="30" selected>30 minutes</option>
            <option value="60">60 minutes</option>
            <option value="15">15 minutes</option>
          </select>
        </div>
        <div>
          <label>Text size</label>
          <input id="fontSize" type="number" min="8" max="18" value="12" />
        </div>
      </div>

      <div class="toggleRow">
        <label><input type="checkbox" id="shadeBlocks" checked> Shade blocks</label>
        <label><input type="checkbox" id="repeatText" checked> Repeat label in each slot</label>
      </div>

      <div class="blocks" id="blocks"></div>

      <div class="btnRow">
        <button id="addBlockBtn">Add Schedule Block</button>
        <button id="printBtn">Print</button>
        <button id="downloadBtn">Download SVG</button>
        <button id="clearBtn">Clear All</button>
      </div>
    </div>

    <div class="stage">
      <!-- Bigger viewBox height + smaller radius below = no overlap -->
      <svg id="svg" viewBox="0 0 900 1500" xmlns="http://www.w3.org/2000/svg" aria-label="Circle planner"></svg>
    </div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const svg = $("svg");
  const blocksWrap = $("blocks");

  const slotModeEl = $("slotMode");
  const fontSizeEl = $("fontSize");
  const shadeBlocksEl = $("shadeBlocks");
  const repeatTextEl = $("repeatText");

  const state = { blocks: [] };

  $("addBlockBtn").addEventListener("click", () => { addBlock(); renderUI(); renderPlanner(); });
  $("clearBtn").addEventListener("click", () => { state.blocks = []; addBlock(); addBlock(); renderUI(); renderPlanner(); });
  $("printBtn").addEventListener("click", () => window.print());
  $("downloadBtn").addEventListener("click", downloadSVG);

  [slotModeEl, fontSizeEl, shadeBlocksEl, repeatTextEl].forEach(el => {
    el.addEventListener("change", renderPlanner);
    el.addEventListener("input", renderPlanner);
  });

  function addBlock(prefill=null){
    const id = (crypto.randomUUID ? crypto.randomUUID() : String(Date.now()+Math.random()));
    state.blocks.push({
      id,
      startH: prefill?.startH ?? "12",
      startM: prefill?.startM ?? "00",
      startMer: prefill?.startMer ?? "AM",
      endH: prefill?.endH ?? "1",
      endM: prefill?.endM ?? "00",
      endMer: prefill?.endMer ?? "AM",
      label: prefill?.label ?? ""
    });
  }

  function hours12(){ return Array.from({length:12},(_,i)=>String(i+1)); }
  function minutesList(){ return ["00","15","30","45"]; }

  function fillSelect(el, items, selected){
    el.innerHTML = "";
    for (const it of items){
      const opt = document.createElement("option");
      opt.value = it;
      opt.textContent = it;
      if (String(it) === String(selected)) opt.selected = true;
      el.appendChild(opt);
    }
  }

  function renderUI(){
    blocksWrap.innerHTML = "";
    state.blocks.forEach((b, idx) => {
      const block = document.createElement("div");
      block.className = "block";

      block.innerHTML = `
        <div class="blockHead">
          <div class="blockTitle">Schedule Block ${idx + 1}</div>
          <button class="removeBtn" ${state.blocks.length===1 ? "disabled" : ""}>Remove</button>
        </div>

        <div class="grid">
          <div>
            <label>Start</label>
            <div class="timeGrid">
              <select data-k="startH"></select>
              <select data-k="startM"></select>
              <select data-k="startMer"><option>AM</option><option>PM</option></select>
            </div>
          </div>

          <div>
            <label>End</label>
            <div class="timeGrid">
              <select data-k="endH"></select>
              <select data-k="endM"></select>
              <select data-k="endMer"><option>AM</option><option>PM</option></select>
            </div>
          </div>
        </div>

        <div style="margin-top:10px;">
          <label>Event</label>
          <input data-k="label" placeholder="Sleep, Appointment, Work..." />
        </div>
      `;

      const q = (sel) => block.querySelector(sel);
      const sH = q('select[data-k="startH"]');
      const sM = q('select[data-k="startM"]');
      const sMer = q('select[data-k="startMer"]');

      const eH = q('select[data-k="endH"]');
      const eM = q('select[data-k="endM"]');
      const eMer = q('select[data-k="endMer"]');

      fillSelect(sH, hours12(), b.startH);
      fillSelect(sM, minutesList(), b.startM);
      sMer.value = b.startMer;

      fillSelect(eH, hours12(), b.endH);
      fillSelect(eM, minutesList(), b.endM);
      eMer.value = b.endMer;

      const labelInput = q('input[data-k="label"]');
      labelInput.value = b.label;

      const wire = (el, key) => {
        el.addEventListener("change", () => { b[key] = el.value; maybeAutoAddNext(idx); renderPlanner(); });
        el.addEventListener("input",  () => { b[key] = el.value; maybeAutoAddNext(idx); renderPlanner(); });
      };
      wire(sH,"startH"); wire(sM,"startM"); wire(sMer,"startMer");
      wire(eH,"endH");   wire(eM,"endM");   wire(eMer,"endMer");
      wire(labelInput,"label");

      q(".removeBtn").addEventListener("click", () => {
        if (state.blocks.length === 1) return;
        state.blocks = state.blocks.filter(x => x.id !== b.id);
        renderUI();
        renderPlanner();
      });

      blocksWrap.appendChild(block);
    });
  }

  function maybeAutoAddNext(idx){
    const isLast = idx === state.blocks.length - 1;
    if (!isLast) return;
    const b = state.blocks[idx];
    if ((b.label || "").trim().length > 0){
      addBlock();
      renderUI();
    }
  }

  function toMinutes12h(hourStr, minStr, mer){
    let h = parseInt(hourStr,10) % 12;
    const m = parseInt(minStr,10);
    if (mer === "PM") h += 12;
    return h*60 + m;
  }

  function renderPlanner(){
    const slotMinutes = parseInt(slotModeEl.value,10) || 30;
    const fontSize = clamp(parseInt(fontSizeEl.value,10) || 12, 8, 18);
    fontSizeEl.value = fontSize;

    const shadeMode = shadeBlocksEl.checked;
    const repeatMode = repeatTextEl.checked;

    const events = [];
    for (const b of state.blocks){
      const label = (b.label || "").trim();
      if (!label) continue;
      const start = toMinutes12h(b.startH, b.startM, b.startMer);
      let end = toMinutes12h(b.endH, b.endM, b.endMer);
      if (end <= start) end += 24*60; // crosses midnight
      events.push({ start, end, label });
    }

    while (svg.firstChild) svg.removeChild(svg.firstChild);

    // Smaller radius + more spacing = guaranteed no overlap
    const cx = 450;
    const R = 250;
    const ringWidth = 88;
    const innerR = R - ringWidth;

    const cyAM = 380;
    const cyPM = 1120; // larger gap

    addText(cx, 65, "TIME TABLE", 26, 950, "middle");
    drawClockFace(cx, cyAM, R, innerR, "AM", slotMinutes);
    drawClockFace(cx, cyPM, R, innerR, "PM", slotMinutes);

    for (const ev of events){
      drawEventOnWindow(ev, cx, cyAM, R, innerR, 0, 12*60, slotMinutes, fontSize, repeatMode, shadeMode);
      drawEventOnWindow(ev, cx, cyPM, R, innerR, 12*60, 24*60, slotMinutes, fontSize, repeatMode, shadeMode);
    }

    function drawEventOnWindow(ev, cx, cy, R, innerR, winStart, winEnd, slotMin, fontSize, repeatMode, shadeMode){
      const s0 = clamp(ev.start, 0, 24*60);
      const e0 = clamp(ev.end,   0, 24*60);
      const start = Math.max(s0, winStart);
      const end   = Math.min(e0, winEnd);
      if (end <= start) return;

      const slots = Math.round((12*60)/slotMin);
      const aSlot = Math.floor((start - winStart)/slotMin);
      const bSlot = Math.ceil((end - winStart)/slotMin);

      if (shadeMode){
        for (let i=aSlot; i<bSlot; i++){
          shadeWedge(cx, cy, innerR, R, slotToAngle(i, slots), slotToAngle(i+1, slots), 0.14);
        }
      }

      if (repeatMode){
        for (let i=aSlot; i<bSlot; i++){
          placeLabel(ev.label, i+0.5, slots, cx, cy, (R+innerR)/2, fontSize);
        }
      } else {
        placeLabel(ev.label, (aSlot+bSlot)/2, slots, cx, cy, (R+innerR)/2, fontSize);
      }
    }

    function shadeWedge(cx, cy, r0, r1, a0, a1, opacity){
      const p0o = polar(cx,cy,r1,a0), p1o = polar(cx,cy,r1,a1);
      const p1i = polar(cx,cy,r0,a1), p0i = polar(cx,cy,r0,a0);
      const largeArc = (a1 - a0) > Math.PI ? 1 : 0;

      const d = [
        `M ${p0o.x} ${p0o.y}`,
        `A ${r1} ${r1} 0 ${largeArc} 1 ${p1o.x} ${p1o.y}`,
        `L ${p1i.x} ${p1i.y}`,
        `A ${r0} ${r0} 0 ${largeArc} 0 ${p0i.x} ${p0i.y}`,
        "Z"
      ].join(" ");

      const path = document.createElementNS("http://www.w3.org/2000/svg","path");
      path.setAttribute("d", d);
      path.setAttribute("fill", "black");
      path.setAttribute("fill-opacity", String(opacity));
      svg.appendChild(path);
    }

    function placeLabel(text, slotMid, slots, cx, cy, rText, fontSize){
      const clean = (text || "").trim();
      if (!clean) return;

      const ang = slotToAngle(slotMid, slots);
      const p = polar(cx,cy,rText,ang);

      const deg = ang * 180/Math.PI;
      let rot = deg + 90;
      if (deg > 90 && deg < 270) rot += 180;

      const lines = wrapText(clean, 14).slice(0,3);

      const t = document.createElementNS("http://www.w3.org/2000/svg","text");
      t.setAttribute("x", p.x);
      t.setAttribute("y", p.y);
      t.setAttribute("fill","black");
      t.setAttribute("font-family","system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif");
      t.setAttribute("font-size", String(fontSize));
      t.setAttribute("font-weight","950");
      t.setAttribute("text-anchor","middle");
      t.setAttribute("dominant-baseline","middle");
      t.setAttribute("transform", `rotate(${rot} ${p.x} ${p.y})`);
      svg.appendChild(t);

      lines.forEach((ln,i)=>{
        const sp = document.createElementNS("http://www.w3.org/2000/svg","tspan");
        sp.setAttribute("x", p.x);
        sp.setAttribute("dy", i===0 ? "0" : String(fontSize+2));
        sp.textContent = ln;
        t.appendChild(sp);
      });
    }

    function drawClockFace(cx,cy,R,innerR,tag,slotMinutes){
      addCircle(cx,cy,R, 3.25);
      addCircle(cx,cy,innerR, 3.25);
      addText(cx, cy + R + 46, tag, 22, 950, "middle");

      const slots = Math.round((12*60)/slotMinutes);
      const majorEvery = Math.max(1, Math.round(60/slotMinutes));
      for (let i=0;i<slots;i++){
        const ang = slotToAngle(i, slots);
        const p1 = polar(cx,cy,innerR, ang);
        const p2 = polar(cx,cy,R, ang);
        addLine(p1.x,p1.y,p2.x,p2.y, (i%majorEvery===0)?3.25:2.0);
      }
      for (let h=0;h<12;h++){
        const label = (h===0) ? "12" : String(h);
        const ang = hourToAngle(h);
        const p = polar(cx,cy,R+26, ang);
        addText(p.x,p.y,label,20,950,"middle");
      }
    }

    function addText(x,y,txt,size,weight,anchor="start"){
      const t = document.createElementNS("http://www.w3.org/2000/svg","text");
      t.setAttribute("x", x); t.setAttribute("y", y);
      t.setAttribute("fill","black");
      t.setAttribute("font-family","system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif");
      t.setAttribute("font-size", String(size));
      t.setAttribute("font-weight", String(weight));
      t.setAttribute("text-anchor", anchor);
      t.setAttribute("dominant-baseline","middle");
      t.textContent = txt;
      svg.appendChild(t);
    }
    function addLine(x1,y1,x2,y2,sw){
      const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
      ln.setAttribute("x1",x1); ln.setAttribute("y1",y1);
      ln.setAttribute("x2",x2); ln.setAttribute("y2",y2);
      ln.setAttribute("stroke","black");
      ln.setAttribute("stroke-width", String(sw));
      ln.setAttribute("stroke-linecap","round");
      svg.appendChild(ln);
    }
    function addCircle(x,y,r,sw){
      const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute("cx",x); c.setAttribute("cy",y); c.setAttribute("r",r);
      c.setAttribute("fill","none");
      c.setAttribute("stroke","black");
      c.setAttribute("stroke-width", String(sw));
      svg.appendChild(c);
    }
    function hourToAngle(h){ return (-Math.PI/2) + (h * (2*Math.PI/12)); }
    function slotToAngle(i,slots){ return (-Math.PI/2) + (i * (2*Math.PI/slots)); }
    function polar(cx,cy,r,a){ return { x: cx + r*Math.cos(a), y: cy + r*Math.sin(a) }; }
    function wrapText(str,maxChars){
      const words = str.split(/\s+/).filter(Boolean);
      const out=[]; let cur="";
      for (const w of words){
        const next = cur ? (cur+" "+w) : w;
        if (next.length<=maxChars) cur=next;
        else{ if(cur) out.push(cur); cur = w.length>maxChars ? w.slice(0,maxChars-1)+"…" : w; }
      }
      if(cur) out.push(cur);
      return out;
    }
    function clamp(n,min,max){ return Math.max(min, Math.min(max,n)); }
  }

  function downloadSVG(){
    const xml = new XMLSerializer().serializeToString(svg);
    const blob = new Blob([xml], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "circle-time-planner.svg";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // Start with 2 blocks visible (like you wanted)
  addBlock({ startH:"12", startM:"00", startMer:"AM", endH:"5", endM:"00", endMer:"AM", label:"Sleep" });
  addBlock();
  renderUI();
  renderPlanner();
})();
</script>
</body>
</html>
