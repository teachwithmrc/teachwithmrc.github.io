<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spelling Picture Worksheet Generator</title>
  <script src="newtry_FULL.js" defer></script>
  <script src="soft_cg_ladders_full.js" defer></script>
  <script src="multisyllabic_wordbanks.js" defer></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    @font-face { font-family:'BoxesFont'; src:url('fonts/boxes2.otf') format('opentype'); }
    @font-face { font-family:'UnderlineFont'; src:url('fonts/underlines.otf') format('opentype'); }

    :root {
      --cvc:#e9f2ff;          --cvc-selected:#1976d2;
      --dig:#f3e9ff;          --dig-selected:#8e24aa;
      --glued:#e8fff4;        --glued-selected:#2e7d32;
      --vce:#fff5e6;          --vce-selected:#ef6c00;
      --rctrl:#f0f5ff;        --rctrl-selected:#3f51b5;
      --vteams:#fff0f6;       --vteams-selected:#d81b60;
      --dip:#eefcfb;          --dip-selected:#00897b;
      --variant:#fff8e1;      --variant-selected:#f9a825;
      --soft:#eef4ff;         --soft-selected:#455a64;
      --multi:#f4f0ff;        --multi-selected:#5e35b1;
      --chip-bg:#f3f6fb;      --chip-text:#263238; --chip-x:#546e7a;
    }

    * { box-sizing: border-box; }
    body { margin: 24px; font-family: 'Poppins', sans-serif; background: #fafafa; color: #111; }
    h1 { text-align: center; margin: 0 0 4px; font-size: 34px; }
    .subtitle { text-align: center; margin: 0 0 14px; color: #555; }

    .layout {
      width: 100%;
      max-width: 1150px;
      margin: 0 auto 16px;
      display: grid;
      grid-template-columns: minmax(260px, 1fr) max-content;
      grid-template-rows: 1fr 1fr;
      gap: 12px;
      align-items: stretch;
    }
    .layout .left { grid-column: 1; grid-row: 1 / span 2; }
    .layout .right-top { grid-column: 2; grid-row: 1; }
    .layout .right-bottom { grid-column: 2; grid-row: 2; }

    .table-section {
      border: 2px solid #000;
      border-radius: 12px;
      background: #fff;
      padding: 14px;
      height: 100%;
      width: 100%;
    }
    .section-label { text-align: center; font-weight: 700; font-size: 18px; margin-bottom: 10px; }

    .skill-menu-compact { display: grid; gap: 10px; }
    .category-grid {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 8px;
    }
    .category-tile {
      border: 2px solid #000;
      border-radius: 10px;
      padding: 10px 8px;
      min-height: 48px;
      background: #fff;
      font: inherit;
      font-size: 14px;
      font-weight: 800;
      cursor: pointer;
      line-height: 1.05;
      transition: transform .08s ease, box-shadow .18s ease, background-color .18s ease, color .18s ease;
    }
    .category-tile:active { transform: translateY(1px); }
    .category-tile.active { color: #fff; box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.22); }
    .category-tile.cvc { background: var(--cvc); }
    .category-tile.cvc.active { background: var(--cvc-selected); }
    .category-tile.dig { background: var(--dig); }
    .category-tile.dig.active { background: var(--dig-selected); }
    .category-tile.glued { background: var(--glued); }
    .category-tile.glued.active { background: var(--glued-selected); }
    .category-tile.vce { background: var(--vce); }
    .category-tile.vce.active { background: var(--vce-selected); }
    .category-tile.rctrl { background: var(--rctrl); }
    .category-tile.rctrl.active { background: var(--rctrl-selected); }
    .category-tile.vteams { background: var(--vteams); }
    .category-tile.vteams.active { background: var(--vteams-selected); }
    .category-tile.dip { background: var(--dip); }
    .category-tile.dip.active { background: var(--dip-selected); }
    .category-tile.variant { background: var(--variant); }
    .category-tile.variant.active { background: var(--variant-selected); color: #111; }
    .category-tile.soft { background: var(--soft); }
    .category-tile.soft.active { background: var(--soft-selected); }
    .category-tile.multi { background: var(--multi); }
    .category-tile.multi.active { background: var(--multi-selected); }

    .subskill-panel {
      border: 2px solid #000;
      border-radius: 12px;
      background: #fff;
      padding: 10px;
    }
    .subskill-title {
      text-align: center;
      font-size: 16px;
      font-weight: 800;
      margin-bottom: 8px;
    }
    .subskills-wrap {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 8px;
    }

    .skill-button {
      border: 2px solid #000;
      border-radius: 10px;
      padding: 6px 10px;
      min-height: 34px;
      font-size: 14px;
      font-weight: 700;
      background: #fff;
      cursor: pointer;
      transition: transform .08s ease, background-color .2s ease, color .2s ease;
    }
    .skill-button:active { transform: translateY(1px); }
    .skill-button.cvc.selected { background: var(--cvc-selected); color: #fff; }
    .skill-button.dig.selected { background: var(--dig-selected); color: #fff; }
    .skill-button.glued.selected { background: var(--glued-selected); color: #fff; }
    .skill-button.vce.selected { background: var(--vce-selected); color: #fff; }
    .skill-button.rctrl.selected { background: var(--rctrl-selected); color: #fff; }
    .skill-button.vteams.selected { background: var(--vteams-selected); color: #fff; }
    .skill-button.dip.selected { background: var(--dip-selected); color: #fff; }
    .skill-button.variant.selected { background: var(--variant-selected); color: #fff; }
    .skill-button.soft.selected { background: var(--soft-selected); color: #fff; }
    .skill-button.multi.selected { background: var(--multi-selected); color: #fff; }

    .option-grid { display: flex; flex-direction: column; align-items: center; gap: 10px; }
    .option-box {
      border: 2px solid #000;
      border-radius: 10px;
      padding: 8px 12px;
      font-weight: 600;
      background: #fff;
      cursor: pointer;
    }
    .option-box.selected { background: #d9c9ff; }
    .option-box.disabled { opacity: 0.45; pointer-events: none; }

    .actions-sticky { position: sticky; top: 8px; }
    .chips-title { margin-top: 8px; text-align: center; font-weight: 700; font-size: 14px; }
    .chips-wrap { margin-top: 7px; display: flex; justify-content: center; flex-wrap: wrap; gap: 7px; min-height: 26px; }
    .chip {
      background: var(--chip-bg);
      color: var(--chip-text);
      border-radius: 999px;
      padding: 5px 9px;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
      box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.08);
    }
    .chip .x {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 700;
      cursor: pointer;
      background: #e8edf2;
      color: var(--chip-x);
    }

    .control-row { margin-top: 10px; display: flex; justify-content: center; align-items: center; gap: 10px; }
    .control-row.radio { flex-wrap: wrap; gap: 12px; }
    .small-label { font-size: 14px; font-weight: 600; }
    .radio-opt { font-size: 13px; font-weight: 600; }
    .fixed-count-note { margin-top: 8px; text-align: center; font-size: 13px; font-weight: 600; color: #333; }
    .btn-row { margin-top: 10px; display: flex; justify-content: center; gap: 10px; }
    button.action {
      border: 2px solid #000;
      border-radius: 10px;
      padding: 9px 16px;
      font-size: 15px;
      font-weight: 700;
      background: #fff;
      cursor: pointer;
    }
    button.action.primary { background: #111; color: #fff; }
    .status { margin-top: 8px; text-align: center; font-size: 12px; color: #666; min-height: 18px; }

    #printArea { max-width: 1200px; margin: 0 auto; }
    .page {
      background: #fff;
      border: 2px solid #000;
      border-radius: 8px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, .12);
      margin: 14px auto;
      width: 8.5in;
      max-width: calc(100% - 20px);
      min-height: 11in;
      padding: 0.45in;
      break-after: page;
      page-break-after: always;
    }
    .page h2 {
      margin: 0 0 6px;
      text-align: center;
      font-size: 30px;
    }
    .name-row {
      display: flex;
      align-items: flex-end;
      justify-content: flex-start;
      gap: 8px;
      margin: 0 0 4px;
    }
    .name-label {
      font-size: 17px;
      font-weight: 700;
      line-height: 1;
      margin: 0;
    }
    .name-blank {
      display: inline-block;
      width: 280px;
      min-width: 280px;
      border-bottom: 2px solid #000;
      height: 16px;
      font-family: "Courier New", monospace;
      font-size: 16px;
      line-height: 1;
    }
    .directions {
      font-size: 12px;
      margin: 0 0 4px;
      line-height: 1.25;
      text-align: center;
    }
    .page-meta {
      text-align: center;
      font-size: 12px;
      color: #444;
      margin-bottom: 8px;
    }

    .worksheet-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }
    .word-bank {
      border: 2px solid #000;
      border-radius: 10px;
      padding: 7px 9px;
      margin: 0 auto 8px;
    }
    .word-bank-title {
      font-size: 13px;
      font-weight: 700;
      text-align: center;
      margin-bottom: 5px;
    }
    .word-bank-list {
      display: grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap: 10px 14px;
      justify-items: center;
      align-items: end;
    }
    .word-pill {
      grid-column: span 2;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 0;
      font-size: 25px;
      font-weight: 700;
      line-height: 1.1;
      background: transparent;
      border: none;
    }
    .word-pill:nth-child(n + 4) {
      transform: translateX(14%);
    }
    .card {
      border: 2px solid #000;
      border-radius: 6px;
      padding: 3px 3px 1px;
      min-height: 240px;
      text-align: center;
      position: relative;
      overflow: hidden;
    }
    .card-num {
      position: absolute;
      top: 6px;
      left: 8px;
      font-weight: 700;
      font-size: 14px;
    }
    .card img {
      margin-top: 9px;
      width: 100%;
      max-width: 184px;
      height: 124px;
      object-fit: contain;
    }
    .missing-img {
      margin: 16px auto 0;
      width: 100%;
      max-width: 184px;
      height: 124px;
      border: 2px dashed #999;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #777;
      font-size: 13px;
      line-height: 1.3;
      padding: 8px;
    }
    .pattern {
      font-size: 78px;
      line-height: 0.9;
      margin-top: 1px;
      transform: none;
      display: flex;
      justify-content: center;
      font-family: 'BoxesFont', monospace;
      font-weight: normal;
      padding: 0;
    }
    .pattern.underlines {
      font-family: 'UnderlineFont', monospace;
      letter-spacing: 0;
    }
    .pattern.underlines span {
      display: inline-block;
      margin: 0 2px;
    }
    .pattern.syllables {
      font-family: 'BoxesFont', monospace;
      transform: none;
      font-size: 52px;
      font-weight: normal;
      letter-spacing: 0;
    }

    .worksheet-page.with-word-bank .card {
      min-height: 322px;
      padding: 2px 2px 0;
    }
    .worksheet-page.with-word-bank .card img,
    .worksheet-page.with-word-bank .missing-img {
      height: 156px;
      max-width: 190px;
      margin-top: 8px;
    }
    .worksheet-page.with-word-bank .pattern {
      font-size: 96px;
      line-height: 0.86;
      margin-top: 0;
    }
    .worksheet-page.no-word-bank .card {
      min-height: 248px;
      padding: 2px 2px 0;
    }
    .worksheet-page.no-word-bank .card img,
    .worksheet-page.no-word-bank .missing-img {
      height: 122px;
      max-width: 176px;
      margin-top: 8px;
    }
    .worksheet-page.no-word-bank .pattern {
      font-size: 88px;
      line-height: 0.85;
      margin-top: 0;
    }

    .answer-table {
      width: 100%;
      border-collapse: collapse;
      border: 2px solid #000;
      margin-top: 12px;
      table-layout: fixed;
    }
    .answer-table td {
      border: 2px solid #000;
      padding: 16px 10px;
      text-align: center;
      font-size: 22px;
      font-weight: 600;
    }
    .footer {
      margin-top: 12px;
      text-align: right;
      font-size: 11px;
      color: #444;
    }

    @media (max-width: 980px) {
      body { margin: 12px; }
      h1 { font-size: 26px; }
      .layout { display: block; }
      .table-section { margin-bottom: 12px; }
      .actions-sticky { position: static; }
      .page h2 { font-size: 24px; }
      .category-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .worksheet-grid { grid-template-columns: repeat(2, 1fr); }
    }

    @media print {
      @page { size: Letter; margin: 0.25in; }
      body { margin: 0; background: #fff; }
      .layout, h1, .subtitle { display: none !important; }
      .page {
        width: auto;
        max-width: none;
        min-height: 0;
        border: none;
        border-radius: 0;
        box-shadow: none;
        margin: 0;
        padding: 0.16in;
      }
      .page h2 { font-size: 24px; margin-bottom: 2px; }
      .name-row { margin-bottom: 3px; gap: 6px; }
      .name-label { font-size: 15px; }
      .name-blank { width: 230px; min-width: 230px; height: 14px; border-bottom-width: 1.8px; }
      .directions { font-size: 11px; line-height: 1.2; margin-bottom: 2px; }
      .page-meta { font-size: 11px; margin-bottom: 4px; }
      .word-bank { margin-bottom: 5px; padding: 5px 7px; }
      .word-bank-title { font-size: 12px; margin-bottom: 4px; }
      .word-bank-list {
        grid-template-columns: repeat(6, minmax(0, 1fr));
        gap: 6px 8px;
      }
      .word-pill {
        font-size: 20px;
      }
      .word-pill:nth-child(n + 4) {
        transform: translateX(12%);
      }
      .worksheet-grid { gap: 6px; }
      .card-num { top: 2px; left: 4px; font-size: 12px; }
      .worksheet-page.with-word-bank .card { min-height: 304px; padding: 1px; }
      .worksheet-page.with-word-bank .card img,
      .worksheet-page.with-word-bank .missing-img { height: 128px; max-width: 172px; margin-top: 7px; }
      .worksheet-page.with-word-bank .pattern { font-size: 86px; margin-top: 0; line-height: 0.84; }
      .worksheet-page.no-word-bank .card { min-height: 216px; padding: 1px; }
      .worksheet-page.no-word-bank .card img,
      .worksheet-page.no-word-bank .missing-img { height: 96px; max-width: 146px; margin-top: 6px; }
      .worksheet-page.no-word-bank .pattern { font-size: 78px; margin-top: 0; line-height: 0.82; }
      .footer { margin-top: 6px; font-size: 9px; }
      .answer-table td { font-size: 18px; padding: 10px 8px; }
    }

    @media screen {
      .page.worksheet-page {
        min-height: 11in;
      }
    }
  </style>
</head>
<body>
  <h1>Spelling Picture Worksheet Generator</h1>
  <p class="subtitle">Choose a category, pick skills, and the worksheet auto-updates. Print when ready.</p>

  <div class="layout">
    <div class="left">
      <div class="table-section">
        <div class="section-label">Step 1: Select Category + Skills</div>
        <div class="skill-menu-compact">
          <div id="categoryGrid" class="category-grid" aria-label="Skill Categories"></div>
          <div id="subSkillPanel" class="subskill-panel">
            <div class="subskill-title">Choose a category above.</div>
            <div class="subskills-wrap"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="right-top">
      <div class="table-section">
        <div class="section-label">Step 2: Include Blends?</div>
        <div class="option-grid">
          <div class="option-box" id="includeBlendsYes">Yes (4+ sounds)</div>
          <div class="option-box selected" id="includeBlendsNo">No (3 sounds)</div>
        </div>
      </div>
    </div>

    <div class="right-bottom">
      <div class="table-section actions-sticky">
        <div class="section-label">Step 3: Auto-Generate & Print</div>

        <div class="chips-title">Skills Selected:</div>
        <div id="chips" class="chips-wrap"></div>

        <div id="formatNote" class="fixed-count-note">Worksheet Type: 6 cards + word bank</div>

        <div class="control-row radio">
          <span class="small-label">Box Style:</span>
          <label class="radio-opt"><input type="radio" name="cellStyle" value="boxes" checked> Elkonin Boxes</label>
          <label class="radio-opt"><input type="radio" name="cellStyle" value="underlines"> Underlines</label>
        </div>

        <div class="control-row radio">
          <span class="small-label">Pattern Mode:</span>
          <label class="radio-opt"><input type="radio" name="patternMode" value="soundBoxes" checked> Sound Boxes</label>
          <label class="radio-opt"><input type="radio" name="patternMode" value="syllables"> Syllable Lengths</label>
        </div>

        <div class="control-row radio">
          <span class="small-label">Multisyllable Count:</span>
          <label class="radio-opt"><input type="radio" name="multisyllCount" value="2" checked> 2</label>
          <label class="radio-opt"><input type="radio" name="multisyllCount" value="3"> 3</label>
          <label class="radio-opt"><input type="radio" name="multisyllCount" value="4plus"> 4+</label>
        </div>

        <div class="control-row radio">
          <span class="small-label">Division Rule:</span>
          <label class="radio-opt"><input type="radio" name="divisionRule" value="all" checked> All</label>
          <label class="radio-opt"><input type="radio" name="divisionRule" value="tiger"> Tiger</label>
          <label class="radio-opt"><input type="radio" name="divisionRule" value="rabbit"> Rabbit</label>
        </div>

        <div class="control-row radio">
          <span class="small-label">Worksheet Type:</span>
          <label class="radio-opt"><input type="radio" name="worksheetMode" value="6" checked> 6 Cards + Word Bank</label>
          <label class="radio-opt"><input type="radio" name="worksheetMode" value="9"> 9 Cards (No Word Bank)</label>
        </div>

        <div class="btn-row">
          <button id="btnGenerate" class="action primary">Generate Now</button>
          <button id="btnPrint" class="action">Print</button>
        </div>
        <div id="status" class="status"></div>
      </div>
    </div>
  </div>

  <div id="printArea"></div>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      if (typeof CSS === "undefined" || typeof CSS.escape !== "function") {
        window.CSS = window.CSS || {};
        CSS.escape = CSS.escape || function(sel) {
          return (sel + "").replace(/[^a-zA-Z0-9_-]/g, "\\\\$&");
        };
      }

      const selectedSkills = new Set();
      let includeBlends = false;
      let imageIndex = null;
      let imageDownloadIndex = null;
      let lastGenerated = [];
      const imageSrcCache = new Map();
      const explicitImageMap = new Map();
      let sourceMapsLoaded = false;
      const RAW_IMAGE_BASE = "https://raw.githubusercontent.com/teachwithmrc/teachwithmrc.github.io/main/images/";
      let worksheetMode = "6";
      const MULTISYLLABIC_SKILLS = new Set([
        "Multisyllabic (Closed)",
        "Multisyllabic (Open)",
        "Multisyllabic (VCe)",
        "Multisyllabic (R-Controlled)",
        "Multisyllabic (Vowel Team)",
        "Multisyllabic (C-le)",
        "Multisyllabic Mixed",
        "Multisyllabic (All 6 Types)"
      ]);

      const printArea = document.getElementById("printArea");
      const statusEl = document.getElementById("status");
      const formatNoteEl = document.getElementById("formatNote");
      const blendsYesEl = document.getElementById("includeBlendsYes");
      const blendsNoEl = document.getElementById("includeBlendsNo");
      const categoryGridEl = document.getElementById("categoryGrid");
      const subSkillPanelEl = document.getElementById("subSkillPanel");
      const imageUrlCheckCache = new Map();
      let activeCategoryId = "cvc";
      let autoGenerateTimer = null;
      let generating = false;
      let rerunRequested = false;
      let seededInlineMaps = false;
      const CATEGORY_CONFIG = [
        {
          id: "cvc",
          label: "CVC",
          title: "CVC Short Vowels",
          buttonClass: "cvc",
          skills: [
            { skill: "Short A", label: "Short A" },
            { skill: "Short E", label: "Short E" },
            { skill: "Short I", label: "Short I" },
            { skill: "Short O", label: "Short O" },
            { skill: "Short U", label: "Short U" },
            { skill: "Mixed CVC", label: "Mixed CVC" },
            { skill: "FLSZ Words", label: "FLSZ" }
          ]
        },
        {
          id: "dig",
          label: "Digraphs",
          title: "Digraphs",
          buttonClass: "dig",
          skills: [
            { skill: "Digraph(ck)", label: "ck" },
            { skill: "Digraph(sh)", label: "sh" },
            { skill: "Digraph(th)", label: "th" },
            { skill: "Digraph(ch)", label: "ch" },
            { skill: "Digraph(wh)", label: "wh" },
            { skill: "Digraphs Mixed", label: "Digraphs Mixed" }
          ]
        },
        {
          id: "glued",
          label: "Glued Sounds",
          title: "Glued Sounds",
          buttonClass: "glued",
          skills: [
            { skill: "Glued(all)", label: "-all" },
            { skill: "Glued(-ng)", label: "-ng" },
            { skill: "Glued(-nk)", label: "-nk" },
            { skill: "Glued Mixed", label: "Glued Mixed" }
          ]
        },
        {
          id: "vce",
          label: "Silent E",
          title: "Silent E (VCe)",
          buttonClass: "vce",
          skills: [
            { skill: "VCe(a_e)", label: "a_e" },
            { skill: "VCe(i_e)", label: "i_e" },
            { skill: "VCe(o_e)", label: "o_e" },
            { skill: "VCe(u_e)", label: "u_e" },
            { skill: "Mixed VCe", label: "Mixed VCe" }
          ]
        },
        {
          id: "rctrl",
          label: "R-Controlled",
          title: "R-Controlled",
          buttonClass: "rctrl",
          skills: [
            { skill: "R-Controlled(ar)", label: "ar" },
            { skill: "R-Controlled(or)", label: "or" },
            { skill: "R-Controlled(er,ir,ur)", label: "er/ir/ur" },
            { skill: "Mixed R-Controlled", label: "Mixed R-Controlled" }
          ]
        },
        {
          id: "vteams",
          label: "Vowel Teams",
          title: "Vowel Teams",
          buttonClass: "vteams",
          skills: [
            { skill: "Long A (ai/ay)", label: "Long A (ai/ay)" },
            { skill: "Long E (ee/ea)", label: "Long E (ee/ea)" },
            { skill: "Long I (igh/y/ie)", label: "Long I (igh/y/ie)" },
            { skill: "Long O (oa/ow/oe)", label: "Long O (oa/ow/oe)" },
            { skill: "Long U (oo/ew/ue)", label: "Long U (oo/ew/ue)" },
            { skill: "Mixed Vowel Teams", label: "Mixed Vowel Teams" }
          ]
        },
        {
          id: "dip",
          label: "Diphthongs",
          title: "Diphthongs",
          buttonClass: "dip",
          skills: [
            { skill: "Diphthongs (oy/oi)", label: "oy/oi" },
            { skill: "Diphthongs (ow/ou)", label: "ow/ou" }
          ]
        },
        {
          id: "variant",
          label: "Variant Vowels",
          title: "Variant Vowels",
          buttonClass: "variant",
          skills: [
            { skill: "Variant Vowels (au/aw)", label: "au/aw" },
            { skill: "Variant Vowel (oo)", label: "oo" }
          ]
        },
        {
          id: "soft",
          label: "Soft C/G",
          title: "Soft C/G Endings",
          buttonClass: "soft",
          skills: [
            { skill: "Soft Endings", label: "Soft Endings (-ce/-ge/-dge)" }
          ]
        },
        {
          id: "multi",
          label: "Multisyllabic",
          title: "Multisyllabic Words",
          buttonClass: "multi",
          skills: [
            { skill: "Multisyllabic (Closed)", label: "Closed" },
            { skill: "Multisyllabic (Open)", label: "Open" },
            { skill: "Multisyllabic (VCe)", label: "VCe" },
            { skill: "Multisyllabic (R-Controlled)", label: "R-Controlled" },
            { skill: "Multisyllabic (Vowel Team)", label: "Vowel Team" },
            { skill: "Multisyllabic (C-le)", label: "C-le" },
            { skill: "Multisyllabic Mixed", label: "Mixed" },
            { skill: "Multisyllabic (All 6 Types)", label: "All 6 Types" }
          ]
        }
      ];

      function isWordBankMode() {
        return worksheetMode === "6";
      }

      function getTargetWordCount() {
        return isWordBankMode() ? 6 : 9;
      }

      function updateFormatNote() {
        if (!formatNoteEl) return;
        formatNoteEl.textContent = isWordBankMode()
          ? "Worksheet Type: 6 cards + word bank"
          : "Worksheet Type: 9 cards (no word bank)";
      }

      function currentMultisyllableCount() {
        return document.querySelector("input[name='multisyllCount']:checked")?.value || "2";
      }

      function currentDivisionRule() {
        return document.querySelector("input[name='divisionRule']:checked")?.value || "all";
      }

      function getEffectiveSyllableCount(item) {
        const normalized = Number(item && item.syllableCount);
        if (Number.isFinite(normalized) && normalized > 0) return normalized;
        return Array.isArray(item?.syllables) ? item.syllables.length : 0;
      }

      function filterMultisyllabicWords(words) {
        const count = currentMultisyllableCount();
        const divisionRule = currentDivisionRule();
        if (!Array.isArray(words)) return [];
        return words.filter((item) => {
          const n = getEffectiveSyllableCount(item);
          const countMatch = count === "4plus" ? n >= 4 : n === Number(count);
          const ruleMatch = divisionRule === "all" || (item && item.divisionRule === divisionRule);
          return countMatch && ruleMatch;
        });
      }

      function hasMultisyllabicSelected() {
        return Array.from(selectedSkills).some((skill) => MULTISYLLABIC_SKILLS.has(skill));
      }

      function syncBlendControls() {
        const lockBlends = hasMultisyllabicSelected();
        blendsYesEl.classList.toggle("disabled", lockBlends);
        blendsNoEl.classList.toggle("disabled", lockBlends);
        if (lockBlends) {
          includeBlends = false;
          blendsNoEl.classList.add("selected");
          blendsYesEl.classList.remove("selected");
        }
      }

      function getCategoryById(id) {
        return CATEGORY_CONFIG.find((group) => group.id === id) || CATEGORY_CONFIG[0];
      }

      function renderCategoryTiles() {
        if (!categoryGridEl) return;
        categoryGridEl.innerHTML = "";
        CATEGORY_CONFIG.forEach((group) => {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "category-tile " + group.buttonClass + (group.id === activeCategoryId ? " active" : "");
          button.textContent = group.label;
          button.addEventListener("click", () => {
            activeCategoryId = group.id;
            renderCategoryTiles();
            renderSubSkillPanel();
          });
          categoryGridEl.appendChild(button);
        });
      }

      function renderSubSkillPanel() {
        if (!subSkillPanelEl) return;
        const group = getCategoryById(activeCategoryId);
        subSkillPanelEl.innerHTML = "";

        const title = document.createElement("div");
        title.className = "subskill-title";
        title.textContent = group.title;
        subSkillPanelEl.appendChild(title);

        const wrap = document.createElement("div");
        wrap.className = "subskills-wrap";

        group.skills.forEach((entry) => {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "skill-button " + group.buttonClass + (selectedSkills.has(entry.skill) ? " selected" : "");
          button.dataset.skill = entry.skill;
          button.textContent = entry.label;
          button.addEventListener("click", () => {
            if (selectedSkills.has(entry.skill)) {
              selectedSkills.delete(entry.skill);
              button.classList.remove("selected");
            } else {
              selectedSkills.add(entry.skill);
              button.classList.add("selected");
            }
            renderChips();
            scheduleAutoGenerate();
          });
          wrap.appendChild(button);
        });
        subSkillPanelEl.appendChild(wrap);
      }

      function renderChips() {
        const wrap = document.getElementById("chips");
        wrap.innerHTML = "";
        Array.from(selectedSkills).forEach((skill) => {
          const chip = document.createElement("div");
          chip.className = "chip";
          chip.innerHTML = "<span>" + skill + "</span><span class='x' title='Remove'>×</span>";
          chip.querySelector(".x").addEventListener("click", () => {
            selectedSkills.delete(skill);
            renderSubSkillPanel();
            renderChips();
            scheduleAutoGenerate();
          });
          wrap.appendChild(chip);
        });
        syncBlendControls();
      }

      function scheduleAutoGenerate(delayMs = 200) {
        if (autoGenerateTimer) clearTimeout(autoGenerateTimer);
        autoGenerateTimer = window.setTimeout(() => {
          autoGenerateTimer = null;
          runGenerate(true);
        }, delayMs);
      }

      async function runGenerate(autoMode) {
        if (generating) {
          rerunRequested = true;
          return;
        }
        generating = true;
        try {
          if (autoMode && selectedSkills.size > 0) {
            statusEl.textContent = "Auto-updating worksheet...";
          }
          await ensureImageIndex();
          await generateWorksheet();
        } finally {
          generating = false;
          if (rerunRequested) {
            rerunRequested = false;
            runGenerate(true);
          }
        }
      }

      document.getElementById("includeBlendsYes").addEventListener("click", () => {
        if (blendsYesEl.classList.contains("disabled")) return;
        includeBlends = true;
        document.getElementById("includeBlendsYes").classList.add("selected");
        document.getElementById("includeBlendsNo").classList.remove("selected");
        scheduleAutoGenerate();
      });

      document.getElementById("includeBlendsNo").addEventListener("click", () => {
        if (blendsNoEl.classList.contains("disabled")) return;
        includeBlends = false;
        document.getElementById("includeBlendsNo").classList.add("selected");
        document.getElementById("includeBlendsYes").classList.remove("selected");
        scheduleAutoGenerate();
      });

      document.getElementById("btnGenerate").addEventListener("click", async () => {
        await runGenerate(false);
      });

      document.querySelectorAll("input[name='worksheetMode']").forEach((radio) => {
        radio.addEventListener("change", () => {
          worksheetMode = document.querySelector("input[name='worksheetMode']:checked")?.value || "6";
          updateFormatNote();
          scheduleAutoGenerate();
        });
      });

      document.querySelectorAll("input[name='cellStyle'], input[name='patternMode'], input[name='multisyllCount'], input[name='divisionRule']")
        .forEach((control) => {
          control.addEventListener("change", () => {
            scheduleAutoGenerate();
          });
        });

      updateFormatNote();
      renderCategoryTiles();
      renderSubSkillPanel();
      renderChips();
      window.setTimeout(() => {
        ensureImageIndex();
        if (!seededInlineMaps) seedLoadedImageMaps();
      }, 0);

      document.getElementById("btnPrint").addEventListener("click", () => {
        if (lastGenerated.length === 0) {
          statusEl.textContent = "Generate a worksheet first.";
          return;
        }
        window.print();
      });

      async function ensureImageIndex() {
        if (imageIndex !== null) return;
        imageIndex = new Map();
        imageDownloadIndex = new Map();
        try {
          const response = await fetch("./jsonimages.json", { cache: "no-store" });
          if (!response.ok) return;
          const list = await response.json();
          if (!Array.isArray(list)) return;

          function setPreferredImage(key, fileName) {
            if (!key) return;
            const existing = imageIndex.get(key);
            const existingIsCopy = !!(existing && / copy\.(png|jpg|jpeg|webp)$/i.test(existing));
            const incomingIsCopy = / copy\.(png|jpg|jpeg|webp)$/i.test(fileName);
            if (!existing || (existingIsCopy && !incomingIsCopy)) {
              imageIndex.set(key, fileName);
            }
          }

          function setPreferredDownload(key, fileName, downloadUrl) {
            if (!key || !downloadUrl) return;
            const existing = imageDownloadIndex.get(key);
            const existingIsCopy = !!(existing && /%20copy\.(png|jpg|jpeg|webp)/i.test(existing));
            const incomingIsCopy = / copy\.(png|jpg|jpeg|webp)$/i.test(fileName || "");
            if (!existing || (existingIsCopy && !incomingIsCopy)) {
              imageDownloadIndex.set(key, downloadUrl);
            }
          }

          for (const item of list) {
            if (!item || !item.name || !/\.(png|jpg|jpeg|webp)$/i.test(item.name)) continue;
            const base = item.name.replace(/\.[^.]+$/, "");
            const key = base.toLowerCase();
            const normalizedKey = normalizeWord(base);
            const noCopy = base.replace(/\s+copy$/i, "");
            const noCopyKey = noCopy.toLowerCase();
            const noCopyNormalized = normalizeWord(noCopy);
            const noDigits = noCopy.replace(/\d+$/g, "");
            const noDigitsKey = noDigits.toLowerCase();
            const noDigitsNormalized = normalizeWord(noDigits);
            setPreferredImage(key, item.name);
            setPreferredImage(normalizedKey, item.name);
            setPreferredImage(noCopyKey, item.name);
            setPreferredImage(noCopyNormalized, item.name);
            setPreferredImage(noDigitsKey, item.name);
            setPreferredImage(noDigitsNormalized, item.name);
            setPreferredDownload(key, item.name, item.download_url);
            setPreferredDownload(normalizedKey, item.name, item.download_url);
            setPreferredDownload(noCopyKey, item.name, item.download_url);
            setPreferredDownload(noCopyNormalized, item.name, item.download_url);
            setPreferredDownload(noDigitsKey, item.name, item.download_url);
            setPreferredDownload(noDigitsNormalized, item.name, item.download_url);
          }
          statusEl.textContent = "Image index loaded.";
        } catch (error) {
          statusEl.textContent = "Image index not loaded. Using direct image checks.";
        }
      }

      function addExplicitImage(word, src) {
        if (!word || !src) return;
        const cleanSrc = src.replace(/^\.?\//, "");
        const keyA = (word + "").toLowerCase().trim();
        const keyB = normalizeWord(word);
        if (keyA) explicitImageMap.set(keyA, cleanSrc);
        if (keyB) explicitImageMap.set(keyB, cleanSrc);
      }

      function parseImageMapText(text) {
        if (!text) return 0;
        let added = 0;

        // Matches: "word": "images/file.png"
        const mapPair = /["']([^"']+)["']\s*:\s*["'](images\/[^"']+\.(?:png|jpg|jpeg|webp))["']/gi;
        let m;
        while ((m = mapPair.exec(text)) !== null) {
          addExplicitImage(m[1], m[2]);
          added += 1;
        }

        // Matches: { word: "word", ..., image: "images/file.png" }
        const rowPair = /word\s*:\s*["']([^"']+)["'][\s\S]{0,160}?image\s*:\s*["'](images\/[^"']+\.(?:png|jpg|jpeg|webp))["']/gi;
        while ((m = rowPair.exec(text)) !== null) {
          addExplicitImage(m[1], m[2]);
          added += 1;
        }

        return added;
      }

      function seedWordImageMap(mapObj) {
        if (!mapObj || typeof mapObj !== "object") return 0;
        let added = 0;
        Object.entries(mapObj).forEach(([word, src]) => {
          if (!word || !src || typeof src !== "string") return;
          if (!/^images\/.+\.(png|jpg|jpeg|webp)$/i.test(src)) return;
          addExplicitImage(word, src);
          added += 1;
        });
        return added;
      }

      function seedLoadedImageMaps() {
        let added = 0;
        if (window.softCGLadderData && window.softCGLadderData.wordImages) {
          added += seedWordImageMap(window.softCGLadderData.wordImages);
        }
        seededInlineMaps = true;
        return added;
      }

      async function loadImageMapFromSource(path) {
        try {
          const response = await fetch(path, { cache: "no-store" });
          if (!response.ok) return 0;
          const text = await response.text();
          return parseImageMapText(text);
        } catch (error) {
          return 0;
        }
      }

      async function ensureSourceImageMaps() {
        if (sourceMapsLoaded) return;
        sourceMapsLoaded = true;
        let totalAdded = seedLoadedImageMaps();
        const sources = [
          "./blendsmaster.js",
          "./digraphs_master_FINAL_v2.js",
          "./glued_sounds_full.js",
          "./vceWordLadders_6words_full.js",
          "./rControlled_full_max_SUPERCOMBINED.js",
          "./soft_cg_ladders_full.js"
        ];

        for (const src of sources) {
          // eslint-disable-next-line no-await-in-loop
          totalAdded += await loadImageMapFromSource(src);
        }
        if (totalAdded > 0) {
          statusEl.textContent = "Loaded source image maps.";
        }
      }

      function normalizeWord(word) {
        return (word || "")
          .toLowerCase()
          .replace(/[^a-z0-9]/g, "");
      }

      function getImageCandidates(word) {
        const clean = (word || "").trim();
        if (!clean) return [];

        const candidates = [];
        const lower = clean.toLowerCase();
        candidates.push(lower);
        candidates.push(lower.replace(/['’]/g, ""));
        candidates.push(normalizeWord(clean));

        const urls = [];
        for (const candidate of candidates) {
          const explicit = explicitImageMap.get(candidate);
          if (explicit) urls.push(explicit);
        }

        if (imageIndex && imageIndex.size > 0) {
          for (const candidate of candidates) {
            const fileName = imageIndex.get(candidate);
            if (fileName) urls.push("images/" + encodeURIComponent(fileName).replace(/%2F/g, "/"));
            const copyName = imageIndex.get(candidate + " copy");
            if (copyName) urls.push("images/" + encodeURIComponent(copyName).replace(/%2F/g, "/"));
          }
        }

        if (imageDownloadIndex && imageDownloadIndex.size > 0) {
          for (const candidate of candidates) {
            const dl = imageDownloadIndex.get(candidate);
            if (dl) urls.push(dl);
          }
        }

        for (const candidate of candidates) {
          if (!candidate) continue;
          urls.push("images/" + encodeURIComponent(candidate) + ".png");
          urls.push("images/" + encodeURIComponent(candidate) + ".jpg");
          urls.push("images/" + encodeURIComponent(candidate) + ".jpeg");
          urls.push("images/" + encodeURIComponent(candidate) + ".webp");
          urls.push(RAW_IMAGE_BASE + encodeURIComponent(candidate) + ".png");
          urls.push(RAW_IMAGE_BASE + encodeURIComponent(candidate) + ".jpg");
          urls.push(RAW_IMAGE_BASE + encodeURIComponent(candidate) + ".jpeg");
          urls.push(RAW_IMAGE_BASE + encodeURIComponent(candidate) + ".webp");
        }

        const unique = [];
        const seen = new Set();
        for (const url of urls) {
          if (seen.has(url)) continue;
          seen.add(url);
          unique.push(url);
        }
        return unique;
      }

      function canLoadImage(url) {
        if (imageUrlCheckCache.has(url)) return imageUrlCheckCache.get(url);
        const pending = new Promise((resolve) => {
          const img = new Image();
          img.onload = () => resolve(true);
          img.onerror = () => resolve(false);
          img.src = url;
        });
        imageUrlCheckCache.set(url, pending);
        return pending;
      }

      async function getVerifiedImageSrc(word) {
        const key = (word || "").toLowerCase();
        if (imageSrcCache.has(key)) return imageSrcCache.get(key);

        const candidates = getImageCandidates(word);
        for (const url of candidates) {
          // eslint-disable-next-line no-await-in-loop
          const ok = await canLoadImage(url);
          if (ok) {
            imageSrcCache.set(key, url);
            return url;
          }
        }

        imageSrcCache.set(key, null);
        return null;
      }

      function getWordFontSize(word) {
        const len = (word || "").length;
        if (len >= 11) return "18px";
        if (len >= 9) return "21px";
        if (len >= 7) return "24px";
        if (len >= 6) return "26px";
        return "30px";
      }

      function getAnswerFontSize(word) {
        const len = (word || "").length;
        if (len >= 12) return "15px";
        if (len >= 10) return "16px";
        if (len >= 8) return "17px";
        return "18px";
      }

      function renderPatternHTML(pattern, useUnderlines) {
        const safePattern = (pattern || "").toString();
        if (!useUnderlines) return safePattern;
        return Array.from(safePattern).map((char) => "<span>" + char + "</span>").join("");
      }

      function syllableCount(item) {
        return getEffectiveSyllableCount(item);
      }

      function getPatternForDisplay(item, useSyllableMode, useUnderlines) {
        if (useSyllableMode) {
          if (item && item.syllableCode) return renderPatternHTML(item.syllableCode, false);
          if (window.multisyllableTools && item) {
            const fromTool = window.multisyllableTools.buildSyllableLengthCode(item);
            return renderPatternHTML(fromTool, false);
          }
          return "";
        }

        const basePattern = (item && item.pattern)
          ? item.pattern
          : ((window.multisyllableTools && item) ? window.multisyllableTools.buildBoxPattern(item) : "");
        return renderPatternHTML(basePattern, useUnderlines);
      }

      function shuffle(arr) {
        const copy = arr.slice();
        for (let i = copy.length - 1; i > 0; i -= 1) {
          const j = Math.floor(Math.random() * (i + 1));
          const tmp = copy[i];
          copy[i] = copy[j];
          copy[j] = tmp;
        }
        return copy;
      }

      function dedupeWords(list) {
        const seen = new Set();
        const out = [];
        for (const item of list) {
          if (!item || !item.word) continue;
          const key = item.word.toLowerCase();
          if (seen.has(key)) continue;
          seen.add(key);
          out.push(item);
        }
        return out;
      }

      function getWordsForSkill(skill, source, blends) {
        const blendSuffixes = [" with Blends", " with Digraphs and Blends"];

        function fetchBase(base) {
          if (MULTISYLLABIC_SKILLS.has(base) || MULTISYLLABIC_SKILLS.has(skill)) {
            return filterMultisyllabicWords(source[base] || []);
          }
          if (!blends) return source[base] || [];
          let result = [];
          blendSuffixes.forEach((suffix) => {
            const key = base + suffix;
            if (source[key]) result = result.concat(source[key]);
          });
          return result;
        }

        function dedupe(list) {
          const seen = new Set();
          const out = [];
          for (const w of list) {
            const key = (w && w.word && w.pattern) ? (w.word + "|" + w.pattern) : JSON.stringify(w);
            if (!seen.has(key)) {
              seen.add(key);
              out.push(w);
            }
          }
          return out;
        }

        switch (skill) {
          case "Short A": return fetchBase("Short A");
          case "Short E": return fetchBase("Short E");
          case "Short I": return fetchBase("Short I");
          case "Short O": return fetchBase("Short O");
          case "Short U": return fetchBase("Short U");
          case "FLSZ Words": return fetchBase("FLSZ Words");
          case "Mixed CVC":
            return [].concat(
              fetchBase("Short A"), fetchBase("Short E"), fetchBase("Short I"),
              fetchBase("Short O"), fetchBase("Short U")
            );

          case "Digraph(ck)": return fetchBase("Digraph(ck)");
          case "Digraph(sh)": return fetchBase("Digraph(sh)");
          case "Digraph(th)": return fetchBase("Digraph(th)");
          case "Digraph(ch)": return fetchBase("Digraph(ch)");
          case "Digraph(wh)": return fetchBase("Digraph(wh)");
          case "Digraphs Mixed":
            return [].concat(
              fetchBase("Digraph(ck)"), fetchBase("Digraph(sh)"),
              fetchBase("Digraph(th)"), fetchBase("Digraph(ch)"),
              fetchBase("Digraph(wh)")
            );

          case "Glued(all)": return fetchBase("Glued(all)");
          case "Glued(-ng)":
            return dedupe([].concat(
              fetchBase("Glued(ang)"), fetchBase("Glued(ing)"),
              fetchBase("Glued(ong)"), fetchBase("Glued(ung)")
            ));
          case "Glued(-nk)":
            return dedupe([].concat(
              fetchBase("Glued(ank)"), fetchBase("Glued(ink)"),
              fetchBase("Glued(onk)"), fetchBase("Glued(unk)")
            ));
          case "Glued Mixed":
            return dedupe([].concat(
              fetchBase("Glued(all)"),
              fetchBase("Glued(ang)"), fetchBase("Glued(ing)"),
              fetchBase("Glued(ong)"), fetchBase("Glued(ung)"),
              fetchBase("Glued(ank)"), fetchBase("Glued(ink)"),
              fetchBase("Glued(onk)"), fetchBase("Glued(unk)")
            ));

          case "VCe(a_e)": return fetchBase("VCe(a_e)");
          case "VCe(i_e)": return fetchBase("VCe(i_e)");
          case "VCe(o_e)": return fetchBase("VCe(o_e)");
          case "VCe(u_e)": return fetchBase("VCe(u_e)");
          case "Mixed VCe":
            return [].concat(
              fetchBase("VCe(a_e)"), fetchBase("VCe(i_e)"),
              fetchBase("VCe(o_e)"), fetchBase("VCe(u_e)")
            );

          case "R-Controlled(ar)": return fetchBase("R-Controlled(ar)");
          case "R-Controlled(or)": return fetchBase("R-Controlled(or)");
          case "R-Controlled(er,ir,ur)": return fetchBase("R-Controlled(er,ir,ur)");
          case "Mixed R-Controlled":
            return [].concat(
              fetchBase("R-Controlled(ar)"), fetchBase("R-Controlled(or)"),
              fetchBase("R-Controlled(er,ir,ur)")
            );

          case "Long A (ai/ay)": return [].concat(fetchBase("Long A(ai)"), fetchBase("Long A(ay)"));
          case "Long E (ee/ea)": return [].concat(fetchBase("Long E(ee)"), fetchBase("Long E(ea)"));
          case "Long I (igh/y/ie)": return [].concat(fetchBase("Long I(igh)"), fetchBase("Long I(y)"), fetchBase("Long I(ie)"));
          case "Long O (oa/ow/oe)": return [].concat(fetchBase("Long O(oa)"), fetchBase("Long O(ow)"), fetchBase("Long O(oe)"));
          case "Long U (oo/ew/ue)": return [].concat(fetchBase("Long U(oo)"), fetchBase("Long U(ew)"), fetchBase("Long U(ue)"));
          case "Mixed Vowel Teams":
            return [].concat(
              fetchBase("Long A(ai)"), fetchBase("Long A(ay)"),
              fetchBase("Long E(ee)"), fetchBase("Long E(ea)"),
              fetchBase("Long I(igh)"), fetchBase("Long I(y)"), fetchBase("Long I(ie)"),
              fetchBase("Long O(oa)"), fetchBase("Long O(ow)"), fetchBase("Long O(oe)"),
              fetchBase("Long U(oo)"), fetchBase("Long U(ew)"), fetchBase("Long U(ue)")
            );

          case "Diphthongs (oy/oi)": return [].concat(fetchBase("Diphthong(oy)"), fetchBase("Diphthong(oi)"));
          case "Diphthongs (ow/ou)": return [].concat(fetchBase("Diphthong(ow)"), fetchBase("Diphthong(ou)"));

          case "Variant Vowels (au/aw)": return [].concat(fetchBase("Variant Vowel(aw)"), fetchBase("Variant Vowel(au)"));
          case "Variant Vowel (oo)": return fetchBase("Variant Vowel(oo)");

          case "Soft Endings":
            return [].concat(fetchBase("Soft C(ce)"), fetchBase("Soft G(ge)"), fetchBase("Soft G(dge)"));

          case "Multisyllabic (Closed)": return fetchBase("Multisyllabic (Closed)");
          case "Multisyllabic (Open)": return fetchBase("Multisyllabic (Open)");
          case "Multisyllabic (VCe)": return fetchBase("Multisyllabic (VCe)");
          case "Multisyllabic (R-Controlled)": return fetchBase("Multisyllabic (R-Controlled)");
          case "Multisyllabic (Vowel Team)": return fetchBase("Multisyllabic (Vowel Team)");
          case "Multisyllabic (C-le)": return fetchBase("Multisyllabic (C-le)");
          case "Multisyllabic Mixed": return fetchBase("Multisyllabic Mixed");
          case "Multisyllabic (All 6 Types)": return fetchBase("Multisyllabic (All 6 Types)");

          default:
            return fetchBase(skill);
        }
      }

      async function collectImageMatches(wordList, targetCount) {
        const selected = [];
        const chunkSize = 12;
        for (let i = 0; i < wordList.length && selected.length < targetCount; i += chunkSize) {
          const chunk = wordList.slice(i, i + chunkSize);
          // eslint-disable-next-line no-await-in-loop
          const results = await Promise.all(chunk.map(async (item) => {
            const src = await getVerifiedImageSrc(item.word);
            return src ? { ...item, _imgSrc: src } : null;
          }));
          for (const match of results) {
            if (!match) continue;
            selected.push(match);
            if (selected.length >= targetCount) break;
          }
        }
        return selected;
      }

      async function generateWorksheet() {
        if (selectedSkills.size === 0) {
          statusEl.textContent = "Select at least one skill.";
          return;
        }
        if (typeof soundBoxWords === "undefined") {
          statusEl.textContent = "Missing data: newtry_FULL.js did not load.";
          return;
        }
        if (!seededInlineMaps) seedLoadedImageMaps();

        const count = getTargetWordCount();
        const source = soundBoxWords;
        let allWords = [];
        selectedSkills.forEach((skill) => {
          allWords = allWords.concat(getWordsForSkill(skill, source, includeBlends));
        });
        const shuffled = shuffle(dedupeWords(allWords));
        let selected = [];

        statusEl.textContent = "Checking image matches...";
        selected = await collectImageMatches(shuffled, count);

        if (selected.length < count && !sourceMapsLoaded) {
          statusEl.textContent = "Checking extra image maps...";
          await ensureSourceImageMaps();
          const alreadyPicked = new Set(selected.map((item) => (item.word || "").toLowerCase()));
          const remaining = shuffled.filter((item) => !alreadyPicked.has((item.word || "").toLowerCase()));
          const topUp = await collectImageMatches(remaining, count - selected.length);
          selected = selected.concat(topUp);
        }

        if (selected.length === 0) {
          statusEl.textContent = "No image-matched words found for this selection.";
          return;
        }

        lastGenerated = selected.slice();
        renderPages(selected);
        if (selected.length < count) {
          statusEl.textContent = "Generated " + selected.length + " cards (requested " + count + "). Only image-matched words were used.";
        } else {
          statusEl.textContent = "Generated " + selected.length + " image-matched cards.";
        }
      }

      function renderPages(words) {
        printArea.innerHTML = "";
        const useSyllableMode = (document.querySelector("input[name='patternMode']:checked")?.value === "syllables");
        const useUnderlines = !useSyllableMode && (document.querySelector("input[name='cellStyle']:checked")?.value === "underlines");
        const useWordBank = isWordBankMode();

        const worksheet = document.createElement("div");
        worksheet.className = "page worksheet-page " + (useWordBank ? "with-word-bank" : "no-word-bank");
        const skillsText = Array.from(selectedSkills).join(", ");

        const nameRow = document.createElement("div");
        nameRow.className = "name-row";
        const nameLabel = document.createElement("div");
        nameLabel.className = "name-label";
        nameLabel.textContent = "Name:";
        const nameBlank = document.createElement("span");
        nameBlank.className = "name-blank";
        nameBlank.setAttribute("aria-hidden", "true");
        nameBlank.textContent = " ";
        nameRow.appendChild(nameLabel);
        nameRow.appendChild(nameBlank);
        worksheet.appendChild(nameRow);

        const title = document.createElement("h2");
        title.textContent = "Dictation/Spelling Practice";
        worksheet.appendChild(title);

        const directions = document.createElement("p");
        directions.className = "directions";
        const modeText = useSyllableMode ? "syllable length code" : "sound boxes (4+ syllable words use syllable code)";
        directions.textContent = useWordBank
          ? "Directions: Use the word bank and write each word in the " + modeText + " for the matching picture."
          : "Directions: Write the correct word in the " + modeText + " for each picture.";
        worksheet.appendChild(directions);

        const meta = document.createElement("div");
        meta.className = "page-meta";
        meta.textContent = skillsText + " | Blends: " + (includeBlends ? "Yes" : "No");
        worksheet.appendChild(meta);

        if (useWordBank) {
          const bank = document.createElement("div");
          bank.className = "word-bank";
          const bankTitle = document.createElement("div");
          bankTitle.className = "word-bank-title";
          bankTitle.textContent = "Word Bank";
          bank.appendChild(bankTitle);
          const bankList = document.createElement("div");
          bankList.className = "word-bank-list";
          const randomizedBank = shuffle(words.slice());
          randomizedBank.forEach((item) => {
            const pill = document.createElement("span");
            pill.className = "word-pill";
            pill.textContent = item.word;
            pill.style.fontSize = getWordFontSize(item.word);
            bankList.appendChild(pill);
          });
          bank.appendChild(bankList);
          worksheet.appendChild(bank);
        }

        const grid = document.createElement("div");
        grid.className = "worksheet-grid";

        words.forEach((item, index) => {
          const card = document.createElement("div");
          card.className = "card";

          const num = document.createElement("div");
          num.className = "card-num";
          num.textContent = String(index + 1) + ".";
          card.appendChild(num);

          const imgSrc = item._imgSrc || "";
          const image = document.createElement("img");
          image.alt = item.word;
          image.loading = "lazy";
          image.src = imgSrc || "";
          image.onerror = () => {
            image.remove();
            const missing = document.createElement("div");
            missing.className = "missing-img";
            missing.textContent = "Missing image: " + item.word;
            card.appendChild(missing);
          };
          card.appendChild(image);

          const pattern = document.createElement("div");
          const forceSyllableCode = !useSyllableMode && syllableCount(item) > 3;
          pattern.className = "pattern " + ((useSyllableMode || forceSyllableCode) ? "syllables" : (useUnderlines ? "underlines" : "boxes"));
          pattern.innerHTML = getPatternForDisplay(item, useSyllableMode || forceSyllableCode, forceSyllableCode ? false : useUnderlines);
          card.appendChild(pattern);

          grid.appendChild(card);
        });

        worksheet.appendChild(grid);

        const footer = document.createElement("div");
        footer.className = "footer";
        footer.textContent = "Copyright - InterventionStation.com - @TeachwithMrC";
        worksheet.appendChild(footer);
        printArea.appendChild(worksheet);

        const answer = document.createElement("div");
        answer.className = "page";
        answer.innerHTML =
          "<h2>Answer Key</h2>" +
          "<div class='page-meta'>" + skillsText + " | Blends: " + (includeBlends ? "Yes" : "No") + "</div>";

        const table = document.createElement("table");
        table.className = "answer-table";
        const cols = 3;
        const rows = Math.ceil(words.length / cols);

        for (let r = 0; r < rows; r += 1) {
          const tr = document.createElement("tr");
          for (let c = 0; c < cols; c += 1) {
            const td = document.createElement("td");
            const i = r * cols + c;
            if (i < words.length) {
              td.textContent = String(i + 1) + ". " + words[i].word;
              td.style.fontSize = getAnswerFontSize(words[i].word);
            } else {
              td.innerHTML = "&nbsp;";
            }
            tr.appendChild(td);
          }
          table.appendChild(tr);
        }

        answer.appendChild(table);
        const footer2 = document.createElement("div");
        footer2.className = "footer";
        footer2.textContent = "Copyright - InterventionStation.com - @TeachwithMrC";
        answer.appendChild(footer2);
        printArea.appendChild(answer);

        printArea.scrollIntoView({ behavior: "smooth", block: "start" });
      }
    });
  </script>
</body>
</html>
