<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Match and Solve Memory Hub</title>
  <script src="fluencyDataFull_v8-2_clean.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;800&amp;display=swap" rel="stylesheet" />
  <style>
    :root {
      --ink: #1d2b3b;
      --bg1: #eef7ff;
      --bg2: #f2fff0;
      --panel: #ffffff;
      --line: #c8d7e5;
      --accent: #1d69b1;
      --accent-soft: #e8f4ff;
      --ok: #2f7a3f;
      --warn: #c96a1a;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 20px;
      font-family: "Poppins", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(circle at 12% 8%, #ffffff 0 8%, transparent 9%),
        radial-gradient(circle at 88% 12%, #ffffff 0 7%, transparent 8%),
        linear-gradient(145deg, var(--bg1), var(--bg2));
    }

    .app {
      max-width: 1240px;
      margin: 0 auto;
      display: grid;
      gap: 12px;
    }

    h1 {
      margin: 0;
      text-align: center;
      font-size: clamp(1.4rem, 2.6vw, 2rem);
      line-height: 1.2;
    }

    .subtitle {
      margin: 0;
      text-align: center;
      color: #46586c;
      font-size: 0.96rem;
    }

    .panel {
      background: var(--panel);
      border: 2px solid #000;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 10px 20px rgba(20, 40, 62, 0.09);
    }

    .panel h2 {
      margin: 0 0 8px;
      font-size: 1.1rem;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .row:last-child {
      margin-bottom: 0;
    }

    .label {
      font-weight: 700;
      font-size: 0.9rem;
      margin-right: 4px;
    }

    .pill {
      border: 2px solid #000;
      border-radius: 999px;
      background: #fff;
      padding: 7px 12px;
      font: inherit;
      font-size: 0.86rem;
      font-weight: 700;
      cursor: pointer;
      line-height: 1;
      user-select: none;
    }

    .pill.selected {
      background: var(--accent-soft);
      color: #0e4478;
      border-color: #0e4478;
    }

    .select-wrap {
      border: 2px solid #000;
      border-radius: 10px;
      background: #fff;
      display: inline-flex;
      align-items: center;
      padding: 3px 8px;
      min-height: 36px;
    }

    select {
      border: 0;
      background: transparent;
      font: inherit;
      font-size: 0.9rem;
      font-weight: 600;
      color: #203246;
      outline: none;
      min-width: 120px;
      cursor: pointer;
    }

    .grid-two {
      display: grid;
      grid-template-columns: 1.1fr 1fr;
      gap: 12px;
    }

    .skills-wrap {
      border: 2px solid #000;
      border-radius: 12px;
      background: #fbfdff;
      padding: 10px;
      max-height: 290px;
      overflow: auto;
    }

    .skills-group {
      border: 1px solid #cedaea;
      border-radius: 10px;
      background: #fff;
      padding: 8px;
      margin-bottom: 8px;
    }

    .skills-group:last-child {
      margin-bottom: 0;
    }

    .skills-group h3 {
      margin: 0 0 6px;
      font-size: 0.84rem;
      color: #37516e;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .skills-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
    }

    .skill-btn {
      border: 2px solid #000;
      border-radius: 10px;
      background: #fff;
      font: inherit;
      font-size: 0.8rem;
      font-weight: 700;
      padding: 7px 8px;
      text-align: center;
      cursor: pointer;
      line-height: 1.1;
    }

    .skill-btn.selected {
      background: #111;
      color: #fff;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      margin-top: 8px;
    }

    button.action {
      border: 2px solid #000;
      border-radius: 10px;
      background: #fff;
      padding: 9px 12px;
      font: inherit;
      font-size: 0.9rem;
      font-weight: 800;
      cursor: pointer;
    }

    button.action.primary {
      background: #dff1ff;
      color: #0f416e;
    }

    .status {
      text-align: center;
      font-weight: 700;
      font-size: 0.9rem;
      min-height: 22px;
      color: #445b72;
    }

    .scoreboard {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
    }

    .score-pill {
      border: 2px solid #000;
      border-radius: 999px;
      background: #fff;
      padding: 6px 12px;
      font-size: 0.85rem;
      font-weight: 700;
    }

    .score-pill.turn {
      background: #ecf6ff;
      border-color: #1b5f9f;
      color: #104a7f;
    }

    .board-shell {
      background: #fff;
      border: 2px solid #000;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 12px 22px rgba(17, 37, 58, 0.11);
    }

    .board {
      display: grid;
      gap: 8px;
      margin: 0 auto;
      width: min(960px, 100%);
      grid-template-columns: repeat(4, minmax(0, 1fr));
    }

    .memory-card {
      border: 0;
      padding: 0;
      background: transparent;
      cursor: pointer;
      perspective: 900px;
      width: 100%;
      aspect-ratio: 1 / 1;
    }

    .memory-card .inner {
      position: relative;
      width: 100%;
      height: 100%;
      transition: transform 240ms ease;
      transform-style: preserve-3d;
    }

    .memory-card.revealed .inner,
    .memory-card.matched .inner {
      transform: rotateY(180deg);
    }

    .face {
      position: absolute;
      inset: 0;
      border: 2px solid #000;
      border-radius: 12px;
      backface-visibility: hidden;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      background: #fff;
      padding: 7px;
    }

    .face.back {
      background: linear-gradient(160deg, #dceefe, #e7fbe7);
      color: #274663;
      font-size: 0.9rem;
      font-weight: 800;
    }

    .face.front {
      transform: rotateY(180deg);
      flex-direction: column;
      gap: 5px;
    }

    .tag {
      font-size: 0.66rem;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #46607a;
      border: 1px solid #b9ccdf;
      border-radius: 999px;
      padding: 2px 7px;
      line-height: 1.2;
      background: #f5faff;
    }

    .prompt-main {
      width: 100%;
      font-weight: 800;
      font-size: clamp(1rem, 2vw, 1.35rem);
      line-height: 1.05;
      word-break: break-word;
      overflow-wrap: anywhere;
    }

    .answer-main {
      font-weight: 900;
      font-size: clamp(1.05rem, 2.2vw, 1.45rem);
      line-height: 1;
      color: #0e446f;
    }

    .rounding-text {
      font-size: 0.92rem;
      line-height: 1.18;
      font-weight: 700;
      color: #334d67;
    }

    .counting-line {
      font-size: 1.04rem;
      font-weight: 800;
      line-height: 1.05;
      letter-spacing: 0.02em;
    }

    .counting-line .blank {
      border-bottom: 2px solid #000;
      display: inline-block;
      min-width: 28px;
      transform: translateY(-1px);
    }

    .tf-wrap {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      align-items: center;
      justify-content: center;
      width: 100%;
    }

    .tf-grid {
      width: min(108px, 100%);
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 4px;
    }

    .tf-cell {
      aspect-ratio: 1;
      border: 1.5px solid #6c86a0;
      border-radius: 4px;
      background: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .tf-dot {
      width: 56%;
      aspect-ratio: 1;
      border-radius: 50%;
      background: #1d6baf;
    }

    .coins-strip {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      justify-content: center;
      align-items: center;
    }

    .coin {
      width: 38px;
      height: 38px;
      border-radius: 50%;
      overflow: hidden;
      border: 1px solid #8498ad;
      background: #fff;
    }

    .coin img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .clock {
      width: min(86px, 100%);
      aspect-ratio: 1;
    }

    .clock svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .clock .ring {
      fill: #ffffff;
      stroke: #274d71;
      stroke-width: 2;
    }

    .clock .tick {
      stroke: #7d95ac;
      stroke-width: 1;
      stroke-linecap: round;
    }

    .clock .hour {
      stroke: #1f3b56;
      stroke-width: 3;
      stroke-linecap: round;
    }

    .clock .minute {
      stroke: #1d70b3;
      stroke-width: 2;
      stroke-linecap: round;
    }

    .clock .center {
      fill: #1f3b56;
    }

    .img-wrap {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .word-image {
      width: min(92px, 100%);
      max-height: 76px;
      object-fit: contain;
      display: block;
    }

    .img-fallback {
      display: none;
      align-items: center;
      justify-content: center;
      width: min(92px, 100%);
      min-height: 58px;
      border: 2px dashed #93abc2;
      border-radius: 10px;
      font-size: 0.88rem;
      font-weight: 700;
      line-height: 1.1;
      padding: 4px;
      color: #49627a;
      background: #f8fbff;
    }

    .win-banner {
      margin-top: 10px;
      border: 2px solid var(--ok);
      border-radius: 12px;
      background: #ecfff1;
      color: #125f30;
      text-align: center;
      font-weight: 900;
      padding: 9px 10px;
      font-size: clamp(0.95rem, 2.2vw, 1.1rem);
    }

    .hidden {
      display: none !important;
    }

    .board-shell:fullscreen,
    .board-shell:-webkit-full-screen {
      width: 100vw;
      height: 100vh;
      max-width: none;
      border-radius: 0;
      border-width: 0;
      padding: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: none;
      background: #f7fbff;
    }

    .board-shell:fullscreen #board,
    .board-shell:-webkit-full-screen #board {
      width: 100%;
      max-width: 100%;
    }

    @media (max-width: 1100px) {
      .grid-two {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 680px) {
      body {
        padding: 12px;
      }

      .skills-grid {
        grid-template-columns: 1fr;
      }

      .prompt-main {
        font-size: clamp(0.92rem, 3.5vw, 1.2rem);
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>Match and Solve Memory Hub</h1>
    <p class="subtitle">Flip cards, solve prompts, and find logical matches. Play solo or in teams.</p>

    <section class="panel">
      <h2>Game Setup</h2>
      <div class="row" id="deckTypeRow">
        <span class="label">Deck Type:</span>
        <button class="pill selected" type="button" data-deck="math">Math</button>
        <button class="pill" type="button" data-deck="reading">Reading</button>
        <button class="pill" type="button" data-deck="mixed">Mixed</button>
      </div>
      <div class="row" id="playModeRow">
        <span class="label">Play Mode:</span>
        <button class="pill selected" type="button" data-play="solo">Solo</button>
        <button class="pill" type="button" data-play="teams">Teams</button>
      </div>
      <div class="row hidden" id="teamCountRow">
        <span class="label">Teams:</span>
        <span class="select-wrap">
          <select id="teamCountSelect">
            <option value="2" selected>2 teams</option>
            <option value="3">3 teams</option>
            <option value="4">4 teams</option>
          </select>
        </span>
      </div>
      <div class="row">
        <span class="label">Board Size:</span>
        <span class="select-wrap">
          <select id="pairCountSelect">
            <option value="6">6 pairs (12 cards)</option>
            <option value="8" selected>8 pairs (16 cards)</option>
            <option value="10">10 pairs (20 cards)</option>
            <option value="12">12 pairs (24 cards)</option>
          </select>
        </span>
      </div>
    </section>

    <div class="grid-two">
      <section class="panel" id="mathPanel">
        <h2>Math Generator Controls</h2>
        <div class="row" id="mathOpsRow">
          <span class="label">Operations:</span>
          <button class="pill selected" type="button" data-op="addition">Addition</button>
          <button class="pill selected" type="button" data-op="subtraction">Subtraction</button>
          <button class="pill selected" type="button" data-op="multiplication">Multiplication</button>
          <button class="pill selected" type="button" data-op="division">Division</button>
          <button class="pill selected" type="button" data-op="rounding">Rounding</button>
          <button class="pill selected" type="button" data-op="counting">Counting</button>
          <button class="pill selected" type="button" data-op="tellingtime">Telling Time</button>
          <button class="pill selected" type="button" data-op="tenframes">Ten Frames</button>
          <button class="pill selected" type="button" data-op="coins">Coins</button>
        </div>
        <div class="row">
          <span class="label">Difficulty:</span>
          <span class="select-wrap">
            <select id="mathDifficultySelect">
              <option value="single" selected>Single</option>
              <option value="double">Double</option>
              <option value="multi">Multi</option>
            </select>
          </span>
        </div>
        <div class="row" id="regroupRow">
          <span class="label">Regrouping:</span>
          <span class="select-wrap">
            <select id="regroupSelect">
              <option value="mixed" selected>Mixed</option>
              <option value="with">With Regrouping</option>
              <option value="without">Without Regrouping</option>
            </select>
          </span>
        </div>
        <div class="row">
          <span class="label">Rounding Style:</span>
          <span class="select-wrap">
            <select id="roundingStyleSelect">
              <option value="standard" selected>Standard</option>
              <option value="numberline">Number Line</option>
            </select>
          </span>
        </div>
        <div class="row">
          <span class="label">Round To:</span>
          <span class="select-wrap">
            <select id="roundingNearestSelect">
              <option value="10" selected>Nearest 10</option>
              <option value="100">Nearest 100</option>
              <option value="1000">Nearest 1000</option>
            </select>
          </span>
          <span class="label">Within:</span>
          <span class="select-wrap">
            <select id="roundingWithinSelect">
              <option value="100" selected>100</option>
              <option value="1000">1,000</option>
              <option value="10000">10,000</option>
              <option value="100000">100,000</option>
            </select>
          </span>
        </div>
        <div class="row">
          <span class="label">Counting:</span>
          <span class="select-wrap">
            <select id="countingStyleSelect">
              <option value="mixed" selected>Mixed</option>
              <option value="forward">Forward</option>
              <option value="backward">Backward</option>
              <option value="missing">Missing Number</option>
            </select>
          </span>
        </div>
      </section>

      <section class="panel" id="readingPanel">
        <h2>Reading Generator Controls</h2>
        <div class="row" id="blendRow">
          <span class="label">Include Blends:</span>
          <button class="pill selected" type="button" data-blends="no">No</button>
          <button class="pill" type="button" data-blends="yes">Yes</button>
        </div>
        <div class="row" id="readingPairTypeRow">
          <span class="label">Pair Type:</span>
          <button class="pill selected" type="button" data-rpair="picture-word">Picture + Word</button>
          <button class="pill" type="button" data-rpair="word-word">Word + Word</button>
        </div>
        <div class="row">
          <span class="label">Selected Skills:</span>
          <span id="selectedSkillsText">Short A</span>
        </div>
        <div class="skills-wrap" id="skillsMount"></div>
      </section>
    </div>

    <section class="panel">
      <div class="toolbar">
        <button id="btnStart" class="action primary" type="button">Start New Board</button>
        <button id="btnShuffle" class="action" type="button">Shuffle Board</button>
        <button id="btnFullscreen" class="action" type="button">Full Screen</button>
        <button id="btnResetScore" class="action" type="button">Reset Score</button>
      </div>
      <div id="statusLine" class="status">Configure settings, then start a board.</div>
    </section>

    <section class="panel">
      <div id="scoreboard" class="scoreboard"></div>
    </section>

    <section class="board-shell">
      <div id="board" class="board cols-4"></div>
      <div id="winBanner" class="win-banner hidden"></div>
    </section>
  </div>

  <script>
    if (typeof CSS === "undefined" || typeof CSS.escape !== "function") {
      window.CSS = window.CSS || {};
      CSS.escape = CSS.escape || function(selector) {
        return String(selector).replace(/[^a-zA-Z0-9_-]/g, "\\$&");
      };
    }

    const COIN_DEFS = {
      quarter: {
        key: "quarter",
        label: "Quarter",
        value: 25,
        ratio: 1.35,
        chunkValues: [5, 5, 5, 5, 5],
        img: "https://storage.googleapis.com/msgsndr/F9vnmU5R8sOuTGoxp5by/media/698d1f7f715cda9ca3b4afc8.png"
      },
      dime: {
        key: "dime",
        label: "Dime",
        value: 10,
        ratio: 1,
        chunkValues: [5, 5],
        img: "https://storage.googleapis.com/msgsndr/F9vnmU5R8sOuTGoxp5by/media/698d1f7f7213971802a4d866.png"
      },
      nickel: {
        key: "nickel",
        label: "Nickel",
        value: 5,
        ratio: 1.18,
        chunkValues: [5],
        img: "https://storage.googleapis.com/msgsndr/F9vnmU5R8sOuTGoxp5by/media/698d1f7f30ec4a3836469e61.png"
      },
      penny: {
        key: "penny",
        label: "Penny",
        value: 1,
        ratio: 1.06,
        chunkValues: [1],
        img: "https://storage.googleapis.com/msgsndr/F9vnmU5R8sOuTGoxp5by/media/698d1f7f3fdd0e810fca84ef.png"
      }
    };

    const COIN_ORDER = ["quarter", "dime", "nickel", "penny"];
    const ROUNDING_WITHIN_OPTIONS = [100, 1000, 10000, 100000];

    const PREFIX = {
      "Short A": "0.1 - Short A",
      "Short O": "0.2 - Short O",
      "Short I": "0.3 - Short I",
      "Short U": "0.4 - Short U",
      "Short E": "0.5 - Short E",
      "FLSZ": "0.6 - FLSZ",
      "ck": "1.1 - ck",
      "sh": "1.2 - sh",
      "th": "1.3 - th",
      "ch": "1.4 - ch",
      "wh": "1.5 - wh",
      "-all": "3.1 - all",
      "-ng": "3.2 - ng",
      "-nk": "3.3 - nk",
      "a_e": "2.1 - a_e",
      "i_e": "2.2 - i_e",
      "o_e": "2.3 - o_e",
      "u_e": "2.4 - u_e",
      "ar": "4.1 - ar",
      "or": "4.2 - or",
      "er/ir/ur": "4.3 - er, ir, ur",
      "Soft C (-ce)": "10.1 - ce",
      "Soft G (-ge)": "10.2 - ge",
      "Soft G (-dge)": "10.3 - dge"
    };

    const MIXED_RULES = {
      "Mixed CVC": ["0.1 - Short A", "0.5 - Short E", "0.3 - Short I", "0.2 - Short O", "0.4 - Short U", "0.6 - FLSZ"],
      "Digraphs Mixed": ["1.1 - ck", "1.2 - sh", "1.3 - th", "1.4 - ch", "1.5 - wh"],
      "Glued Mixed": ["3.1 - all", "3.2 - ng", "3.3 - nk"],
      "Mixed VCe": ["2.1 - a_e", "2.2 - i_e", "2.3 - o_e", "2.4 - u_e"],
      "Mixed R-Controlled": ["4.1 - ar", "4.2 - or", "4.3 - er, ir, ur"],
      "Long A (ai/ay)": ["6.1 - ay", "6.2 - ai"],
      "Long E (ee/ea)": ["6.4 - ee", "6.5 - ea"],
      "Long I (igh/y/ie)": ["6.6 - igh", "6.7 - Final y", "6.8 - ie"],
      "Long O (oa/ow/oe)": ["6.9 - oa", "6.10 - ow", "6.11 - oe"],
      "Long U (oo/ew/ue)": ["6.12 - oo (long u)", "6.13 - ew", "6.14 - ue"],
      "Mixed Vowel Teams": [
        "6.1 - ay", "6.2 - ai", "6.4 - ee", "6.5 - ea",
        "6.6 - igh", "6.7 - Final y", "6.8 - ie",
        "6.9 - oa", "6.10 - ow", "6.11 - oe",
        "6.12 - oo (long u)", "6.13 - ew", "6.14 - ue"
      ],
      "Diphthongs (oy/oi)": ["7.4 - oy", "7.3 - oi"],
      "Diphthongs (ow/ou)": ["7.2 - ow", "7.1 - ou"],
      "Variant Vowels (au/aw)": ["7.5 - aw", "7.6 - au"],
      "Variant Vowel (oo)": ["7.7 - oo variant"]
    };

    const SKILL_GROUPS = [
      { name: "CVC", skills: ["Short A", "Short E", "Short I", "Short O", "Short U", "Mixed CVC", "FLSZ"] },
      { name: "Digraphs", skills: ["ck", "sh", "th", "ch", "wh", "Digraphs Mixed"] },
      { name: "Glued", skills: ["-all", "-ng", "-nk", "Glued Mixed"] },
      { name: "Silent E", skills: ["a_e", "i_e", "o_e", "u_e", "Mixed VCe"] },
      { name: "R-Controlled", skills: ["ar", "or", "er/ir/ur", "Mixed R-Controlled"] },
      { name: "Vowel Teams", skills: ["Long A (ai/ay)", "Long E (ee/ea)", "Long I (igh/y/ie)", "Long O (oa/ow/oe)", "Long U (oo/ew/ue)", "Mixed Vowel Teams"] },
      { name: "Diphthongs", skills: ["Diphthongs (oy/oi)", "Diphthongs (ow/ou)"] },
      { name: "Variant Vowels", skills: ["Variant Vowels (au/aw)", "Variant Vowel (oo)"] },
      { name: "Soft C/G", skills: ["Soft C (-ce)", "Soft G (-ge)", "Soft G (-dge)"] }
    ];

    const state = {
      deckType: "math",
      playMode: "solo",
      teamCount: 2,
      pairCount: 8,
      mathOperations: new Set(["addition", "subtraction", "multiplication", "division", "rounding", "counting", "tellingtime", "tenframes", "coins"]),
      difficulty: "single",
      regroupMode: "mixed",
      roundingStyle: "standard",
      roundingNearest: 10,
      roundingWithin: 100,
      countingStyle: "mixed",
      includeBlends: false,
      readingPairType: "picture-word",
      selectedSkills: new Set(["Short A"]),
      cards: [],
      revealed: [],
      matchedCount: 0,
      locked: false,
      boardComplete: false,
      turnCount: 0,
      mismatchCount: 0,
      teamScores: [0, 0, 0, 0],
      currentTeam: 0,
      startedAtMs: 0,
      elapsedSeconds: 0,
      timerId: null
    };

    const imageIndex = {
      loaded: false,
      loading: false,
      map: new Map()
    };

    const deckTypeRow = document.getElementById("deckTypeRow");
    const playModeRow = document.getElementById("playModeRow");
    const teamCountRow = document.getElementById("teamCountRow");
    const teamCountSelect = document.getElementById("teamCountSelect");
    const pairCountSelect = document.getElementById("pairCountSelect");
    const mathPanel = document.getElementById("mathPanel");
    const readingPanel = document.getElementById("readingPanel");
    const mathOpsRow = document.getElementById("mathOpsRow");
    const mathDifficultySelect = document.getElementById("mathDifficultySelect");
    const regroupSelect = document.getElementById("regroupSelect");
    const roundingStyleSelect = document.getElementById("roundingStyleSelect");
    const roundingNearestSelect = document.getElementById("roundingNearestSelect");
    const roundingWithinSelect = document.getElementById("roundingWithinSelect");
    const countingStyleSelect = document.getElementById("countingStyleSelect");
    const blendRow = document.getElementById("blendRow");
    const readingPairTypeRow = document.getElementById("readingPairTypeRow");
    const skillsMount = document.getElementById("skillsMount");
    const selectedSkillsText = document.getElementById("selectedSkillsText");
    const btnStart = document.getElementById("btnStart");
    const btnShuffle = document.getElementById("btnShuffle");
    const btnFullscreen = document.getElementById("btnFullscreen");
    const btnResetScore = document.getElementById("btnResetScore");
    const statusLine = document.getElementById("statusLine");
    const scoreboardEl = document.getElementById("scoreboard");
    const boardEl = document.getElementById("board");
    const boardShell = document.querySelector(".board-shell");
    const winBanner = document.getElementById("winBanner");

    let promptIdCounter = 1;

    function toArray(value) {
      if (Array.isArray(value)) return value.slice();
      if (value == null) return [];
      try { return Array.from(value); } catch (_) { return []; }
    }

    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function choose(list) {
      return list[randInt(0, list.length - 1)];
    }

    function shuffle(list) {
      const out = toArray(list);
      for (let i = out.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        const temp = out[i];
        out[i] = out[j];
        out[j] = temp;
      }
      return out;
    }

    function uniqueByLowercase(list) {
      const seen = new Set();
      const out = [];
      for (const item of toArray(list)) {
        const value = String(item || "").trim();
        const key = value.toLowerCase();
        if (value && !seen.has(key)) {
          seen.add(key);
          out.push(value);
        }
      }
      return out;
    }

    function fillToN(list, n) {
      const base = toArray(list);
      if (!base.length || n <= 0) return [];
      const out = [];
      let bag = shuffle(base);
      while (out.length < n) {
        if (!bag.length) bag = shuffle(base);
        out.push(bag.shift());
      }
      return out.slice(0, n);
    }

    function htmlEscape(value) {
      return String(value)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;");
    }

    function normalizeWord(value) {
      return String(value || "")
        .toLowerCase()
        .replace(/['’`]/g, "")
        .replace(/[^a-z0-9]/g, "");
    }

    function formatNumber(value) {
      return Number(value).toLocaleString("en-US");
    }

    function nextPromptId(prefix) {
      const id = `${prefix}${String(promptIdCounter)}`;
      promptIdCounter += 1;
      return id;
    }

    function timeLabel(totalSeconds) {
      const safe = Math.max(0, Math.floor(totalSeconds || 0));
      const min = Math.floor(safe / 60);
      const sec = safe % 60;
      return `${String(min).padStart(2, "0")}:${String(sec).padStart(2, "0")}`;
    }

    function setStatus(text) {
      statusLine.textContent = text;
    }

    function updateVisibility() {
      const hasMath = state.deckType === "math" || state.deckType === "mixed";
      const hasReading = state.deckType === "reading" || state.deckType === "mixed";
      mathPanel.classList.toggle("hidden", !hasMath);
      readingPanel.classList.toggle("hidden", !hasReading);
      teamCountRow.classList.toggle("hidden", state.playMode !== "teams");
    }

    function updateSkillLabel() {
      const list = Array.from(state.selectedSkills);
      selectedSkillsText.textContent = list.length ? list.join(", ") : "None";
    }

    function renderSkills() {
      skillsMount.innerHTML = "";
      SKILL_GROUPS.forEach((group) => {
        const box = document.createElement("section");
        box.className = "skills-group";

        const title = document.createElement("h3");
        title.textContent = group.name;
        box.appendChild(title);

        const grid = document.createElement("div");
        grid.className = "skills-grid";

        group.skills.forEach((skill) => {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "skill-btn" + (state.selectedSkills.has(skill) ? " selected" : "");
          button.textContent = skill;
          button.dataset.skill = skill;
          button.addEventListener("click", () => {
            if (state.selectedSkills.has(skill)) {
              state.selectedSkills.delete(skill);
            } else {
              state.selectedSkills.add(skill);
            }
            if (!state.selectedSkills.size) state.selectedSkills.add("Short A");
            renderSkills();
            updateSkillLabel();
          });
          grid.appendChild(button);
        });

        box.appendChild(grid);
        skillsMount.appendChild(box);
      });
    }

    function renderScoreboard() {
      const parts = [];
      parts.push(`<div class="score-pill">Pairs Found: ${state.matchedCount}/${state.pairCount}</div>`);
      parts.push(`<div class="score-pill">Time: ${timeLabel(state.elapsedSeconds)}</div>`);
      if (state.playMode === "solo") {
        parts.push(`<div class="score-pill">Turns: ${state.turnCount}</div>`);
        parts.push(`<div class="score-pill">Misses: ${state.mismatchCount}</div>`);
      } else {
        parts.push(`<div class="score-pill turn">Turn: Team ${state.currentTeam + 1}</div>`);
        for (let i = 0; i < state.teamCount; i += 1) {
          parts.push(`<div class="score-pill">Team ${i + 1}: ${state.teamScores[i]} pairs</div>`);
        }
      }
      scoreboardEl.innerHTML = parts.join("");
    }

    function boardColumnCount(cardTotal) {
      if (cardTotal >= 24) return 6;
      if (cardTotal >= 20) return 5;
      return 4;
    }

    function applyBoardLayout() {
      const cardTotal = state.cards.length || (state.pairCount * 2) || 16;
      let cols = boardColumnCount(cardTotal);
      if (window.matchMedia("(max-width: 680px)").matches) {
        cols = Math.min(cols, 3);
      }
      const rows = Math.max(1, Math.ceil(cardTotal / cols));
      const gapPx = 8;

      boardEl.style.gridTemplateColumns = `repeat(${cols}, minmax(0, 1fr))`;
      boardEl.style.gap = `${gapPx}px`;

      if (getFullscreenElement() !== boardShell) {
        boardEl.style.width = "min(960px, 100%)";
        return;
      }

      const shellRect = boardShell.getBoundingClientRect();
      const shellStyles = window.getComputedStyle(boardShell);
      const padX = (parseFloat(shellStyles.paddingLeft) || 0) + (parseFloat(shellStyles.paddingRight) || 0);
      const padY = (parseFloat(shellStyles.paddingTop) || 0) + (parseFloat(shellStyles.paddingBottom) || 0);
      const maxWidth = Math.max(0, shellRect.width - padX);
      const maxHeight = Math.max(0, shellRect.height - padY);
      const cardByWidth = (maxWidth - (gapPx * (cols - 1))) / cols;
      const cardByHeight = (maxHeight - (gapPx * (rows - 1))) / rows;
      const cardSize = Math.max(52, Math.floor(Math.min(cardByWidth, cardByHeight)));
      const boardWidth = Math.max(0, (cardSize * cols) + (gapPx * (cols - 1)));

      boardEl.style.width = `${Math.min(maxWidth, boardWidth)}px`;
    }

    function fullscreenSupported() {
      return Boolean(
        document.fullscreenEnabled ||
        document.webkitFullscreenEnabled ||
        document.msFullscreenEnabled
      );
    }

    function getFullscreenElement() {
      return document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || null;
    }

    function requestElementFullscreen(element) {
      if (!element) return Promise.resolve();
      if (element.requestFullscreen) return element.requestFullscreen();
      if (element.webkitRequestFullscreen) return element.webkitRequestFullscreen();
      if (element.msRequestFullscreen) return element.msRequestFullscreen();
      return Promise.resolve();
    }

    function exitDocumentFullscreen() {
      if (document.exitFullscreen) return document.exitFullscreen();
      if (document.webkitExitFullscreen) return document.webkitExitFullscreen();
      if (document.msExitFullscreen) return document.msExitFullscreen();
      return Promise.resolve();
    }

    function updateFullscreenButton() {
      if (!fullscreenSupported()) {
        btnFullscreen.disabled = true;
        btnFullscreen.textContent = "Full Screen Unavailable";
        applyBoardLayout();
        return;
      }
      btnFullscreen.disabled = false;
      btnFullscreen.textContent = getFullscreenElement() === boardShell ? "Exit Full Screen" : "Full Screen";
      applyBoardLayout();
    }

    function pointAtAngle(cx, cy, radius, angleDegrees) {
      const radians = (angleDegrees - 90) * (Math.PI / 180);
      return {
        x: cx + (radius * Math.cos(radians)),
        y: cy + (radius * Math.sin(radians))
      };
    }

    function renderClockSvg(hour, minute) {
      const minuteAngle = minute * 6;
      const hourAngle = ((hour % 12) + (minute / 60)) * 30;
      const hourTip = pointAtAngle(50, 50, 20, hourAngle);
      const minuteTip = pointAtAngle(50, 50, 30, minuteAngle);
      const ticks = [];
      for (let i = 0; i < 12; i += 1) {
        const outer = pointAtAngle(50, 50, 43, i * 30);
        const inner = pointAtAngle(50, 50, 37, i * 30);
        ticks.push(`<line class="tick" x1="${inner.x.toFixed(2)}" y1="${inner.y.toFixed(2)}" x2="${outer.x.toFixed(2)}" y2="${outer.y.toFixed(2)}"></line>`);
      }
      return `
        <div class="clock" aria-hidden="true">
          <svg viewBox="0 0 100 100">
            <circle class="ring" cx="50" cy="50" r="46"></circle>
            ${ticks.join("")}
            <line class="hour" x1="50" y1="50" x2="${hourTip.x.toFixed(2)}" y2="${hourTip.y.toFixed(2)}"></line>
            <line class="minute" x1="50" y1="50" x2="${minuteTip.x.toFixed(2)}" y2="${minuteTip.y.toFixed(2)}"></line>
            <circle class="center" cx="50" cy="50" r="2.4"></circle>
          </svg>
        </div>`;
    }

    function renderTenFrame(total) {
      let remaining = Math.max(0, Number(total) || 0);
      const frames = [];
      const frameCount = Math.ceil(remaining / 10);
      for (let frame = 0; frame < frameCount; frame += 1) {
        const fill = Math.min(10, remaining);
        remaining -= fill;
        const cells = [];
        for (let i = 0; i < 10; i += 1) {
          cells.push(`<div class="tf-cell">${i < fill ? '<span class="tf-dot"></span>' : ""}</div>`);
        }
        frames.push(`<div class="tf-grid">${cells.join("")}</div>`);
      }
      return `<div class="tf-wrap">${frames.join("")}</div>`;
    }

    function renderCoins(coins) {
      const html = coins.map((coin) => {
        return `<div class="coin"><img src="${coin.img}" alt="${htmlEscape(coin.label)}"></div>`;
      }).join("");
      return `<div class="coins-strip">${html}</div>`;
    }

    function renderCardContent(content, roleLabel) {
      if (content.kind === "math-expression") {
        return `<div class="tag">${roleLabel}</div><div class="prompt-main">${htmlEscape(content.text)}</div>`;
      }
      if (content.kind === "math-rounding") {
        return `<div class="tag">${roleLabel}</div><div class="rounding-text">Round <b>${htmlEscape(content.number)}</b><br>to nearest <b>${htmlEscape(content.place)}</b></div>`;
      }
      if (content.kind === "math-counting") {
        return `<div class="tag">${roleLabel}</div><div class="counting-line">${content.sequenceHtml}</div>`;
      }
      if (content.kind === "math-tenframe") {
        return `<div class="tag">${roleLabel}</div>${renderTenFrame(content.total)}`;
      }
      if (content.kind === "math-time") {
        return `<div class="tag">${roleLabel}</div>${renderClockSvg(content.hour, content.minute)}`;
      }
      if (content.kind === "math-coins") {
        return `<div class="tag">${roleLabel}</div>${renderCoins(content.coins)}`;
      }
      if (content.kind === "reading-image") {
        const safeWord = htmlEscape(content.word);
        const imgBlock = content.src
          ? `<img class="word-image" src="${content.src}" alt="${safeWord}" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"><div class="img-fallback">${safeWord}</div>`
          : `<div class="img-fallback" style="display:flex">${safeWord}</div>`;
        return `<div class="tag">${roleLabel}</div><div class="img-wrap">${imgBlock}</div>`;
      }
      return `<div class="tag">${roleLabel}</div><div class="answer-main">${htmlEscape(content.text || "")}</div>`;
    }

    function renderBoard() {
      boardEl.className = "board";
      applyBoardLayout();
      boardEl.innerHTML = "";

      state.cards.forEach((card, index) => {
        const isRevealed = state.revealed.includes(index);
        const classes = ["memory-card"];
        if (isRevealed) classes.push("revealed");
        if (card.matched) classes.push("matched");

        const button = document.createElement("button");
        button.type = "button";
        button.className = classes.join(" ");
        button.disabled = card.matched || isRevealed || state.locked || state.boardComplete;
        button.setAttribute("aria-label", "Memory card");
        button.innerHTML = `
          <div class="inner">
            <div class="face back">Match &amp; Solve</div>
            <div class="face front">
              ${renderCardContent(card.content, card.side === "prompt" ? "Prompt" : "Match")}
            </div>
          </div>`;
        button.addEventListener("click", () => handleCardClick(index));
        boardEl.appendChild(button);
      });
    }

    function wordsDict() {
      return (typeof fluencyWords !== "undefined")
        ? fluencyWords
        : ((typeof fluencyData !== "undefined" && fluencyData.words) ? fluencyData.words : {});
    }

    function readDict(dict, key) {
      return Array.isArray(dict[key]) ? dict[key] : [];
    }

    function readWithBlends(dict, prefix, type, blends) {
      const typeLower = type.toLowerCase();
      const baseKeys = [`${prefix} ${type}`, `${prefix} ${typeLower}`, `${prefix}`];
      let base = [];
      for (const key of baseKeys) {
        base = base.concat(readDict(dict, key));
      }

      if (blends) {
        const candidates = [
          `${prefix} with Blends ${type}`,
          `${prefix} with blends ${type}`,
          `${prefix} with Blends ${typeLower}`,
          `${prefix} with blends ${typeLower}`,
          `${prefix} with BLENDS ${type}`
        ];
        const blendPrefix = prefix.replace(" - ", "b - ");
        candidates.push(
          `${blendPrefix} with Blends ${type}`,
          `${blendPrefix} with blends ${type}`,
          `${blendPrefix} with Blends ${typeLower}`,
          `${blendPrefix} with blends ${typeLower}`
        );
        for (const key of candidates) {
          const got = readDict(dict, key);
          if (got.length) {
            const minBackfill = 9;
            return got.length < minBackfill ? uniqueByLowercase(got.concat(base)) : got;
          }
        }
      }
      return base;
    }

    function getReadingList(skillLabel) {
      const dict = wordsDict();
      if (Object.prototype.hasOwnProperty.call(MIXED_RULES, skillLabel)) {
        let all = [];
        for (const prefix of MIXED_RULES[skillLabel]) {
          all = all.concat(readWithBlends(dict, prefix, "Words", state.includeBlends));
        }
        return all;
      }
      const prefix = PREFIX[skillLabel];
      if (prefix) return readWithBlends(dict, prefix, "Words", state.includeBlends);
      const guessKeys = Object.keys(dict).filter((key) => key.toLowerCase().includes(skillLabel.toLowerCase()));
      let out = [];
      guessKeys.forEach((key) => {
        out = out.concat(readDict(dict, key));
      });
      return out;
    }

    function buildReadingWordPool() {
      const selected = Array.from(state.selectedSkills);
      let pool = [];
      selected.forEach((skill) => {
        pool = pool.concat(getReadingList(skill));
      });
      return uniqueByLowercase(pool);
    }

    async function ensureImageIndexLoaded() {
      if (imageIndex.loaded || imageIndex.loading) return;
      imageIndex.loading = true;
      try {
        const response = await fetch("./jsonimages.json", { cache: "no-store" });
        if (!response.ok) throw new Error("Failed to load jsonimages");
        const rows = await response.json();
        rows.forEach((item) => {
          if (!item || typeof item.name !== "string") return;
          if (!/\.(png|jpg|jpeg|webp)$/i.test(item.name)) return;
          const base = item.name.replace(/\.(png|jpg|jpeg|webp)$/i, "");
          const key = normalizeWord(base);
          if (!key) return;
          const src = item.path || item.download_url || "";
          if (src && !imageIndex.map.has(key)) imageIndex.map.set(key, src);
        });
        imageIndex.loaded = true;
      } catch (_) {
        imageIndex.loaded = false;
      } finally {
        imageIndex.loading = false;
      }
    }

    function resolveWordImage(word) {
      const key = normalizeWord(word);
      if (!key) return "";
      if (imageIndex.map.has(key)) return imageIndex.map.get(key);
      return "";
    }

    function rangeByDifficulty() {
      if (state.difficulty === "single") return { min: 0, max: 9 };
      if (state.difficulty === "double") return { min: 10, max: 99 };
      return { min: 100, max: 999 };
    }

    function digitsForDifficulty() {
      if (state.difficulty === "single") return 1;
      if (state.difficulty === "double") return 2;
      return 3;
    }

    function hasAdditionRegroup(a, b, digits) {
      let carry = 0;
      for (let i = 0; i < digits; i += 1) {
        const da = Math.floor(a / (10 ** i)) % 10;
        const db = Math.floor(b / (10 ** i)) % 10;
        const sum = da + db + carry;
        if (sum >= 10) return true;
        carry = sum >= 10 ? 1 : 0;
      }
      return false;
    }

    function hasSubtractionRegroup(a, b, digits) {
      let borrow = 0;
      for (let i = 0; i < digits; i += 1) {
        const da = (Math.floor(a / (10 ** i)) % 10) - borrow;
        const db = Math.floor(b / (10 ** i)) % 10;
        if (da < db) return true;
        borrow = 0;
      }
      return false;
    }

    function matchesRegroupMode(hasRegroup) {
      if (state.regroupMode === "mixed") return true;
      if (state.regroupMode === "with") return hasRegroup;
      return !hasRegroup;
    }

    function coinConfig() {
      if (state.difficulty === "single") return { maxTotal: 35, minCoins: 2, maxCoins: 4, allowed: ["penny", "nickel", "dime"] };
      if (state.difficulty === "double") return { maxTotal: 99, minCoins: 3, maxCoins: 6, allowed: ["penny", "nickel", "dime", "quarter"] };
      return { maxTotal: 250, minCoins: 4, maxCoins: 9, allowed: ["penny", "nickel", "dime", "quarter"] };
    }

    function makeCoinPrompt() {
      const cfg = coinConfig();
      const coinCount = randInt(cfg.minCoins, cfg.maxCoins);
      let picks = [];
      let total = 0;
      for (let tries = 0; tries < 400; tries += 1) {
        picks = [];
        for (let i = 0; i < coinCount; i += 1) {
          picks.push(COIN_DEFS[choose(cfg.allowed)]);
        }
        total = picks.reduce((sum, coin) => sum + coin.value, 0);
        if (total > 0 && total <= cfg.maxTotal) break;
      }
      picks = picks.slice().sort((a, b) => {
        if (b.value !== a.value) return b.value - a.value;
        return COIN_ORDER.indexOf(a.key) - COIN_ORDER.indexOf(b.key);
      });
      return {
        kind: "coins",
        answer: total,
        coins: picks.map((coin) => ({
          label: coin.label,
          value: coin.value,
          img: coin.img
        }))
      };
    }

    function makeAdditionPrompt() {
      const range = rangeByDifficulty();
      const digits = digitsForDifficulty();
      let a = 0;
      let b = 0;
      let found = false;
      for (let tries = 0; tries < 1200; tries += 1) {
        const minValue = digits === 1 ? 0 : range.min;
        a = randInt(minValue, range.max);
        b = randInt(minValue, range.max);
        if (matchesRegroupMode(hasAdditionRegroup(a, b, digits))) {
          found = true;
          break;
        }
      }
      if (!found) {
        a = randInt(digits === 1 ? 0 : range.min, range.max);
        b = randInt(digits === 1 ? 0 : range.min, range.max);
      }
      return { kind: "math", answer: a + b, text: `${formatNumber(a)} + ${formatNumber(b)}` };
    }

    function makeSubtractionPrompt() {
      const range = rangeByDifficulty();
      const digits = digitsForDifficulty();
      let a = 0;
      let b = 0;
      let found = false;
      for (let tries = 0; tries < 1600; tries += 1) {
        const minValue = digits === 1 ? 0 : range.min;
        a = randInt(minValue, range.max);
        b = randInt(minValue, range.max);
        if (b > a) {
          const t = a;
          a = b;
          b = t;
        }
        if (matchesRegroupMode(hasSubtractionRegroup(a, b, digits))) {
          found = true;
          break;
        }
      }
      if (!found) {
        a = randInt(digits === 1 ? 0 : range.min, range.max);
        b = randInt(digits === 1 ? 0 : range.min, range.max);
        if (b > a) {
          const t = a;
          a = b;
          b = t;
        }
      }
      return { kind: "math", answer: a - b, text: `${formatNumber(a)} - ${formatNumber(b)}` };
    }

    function makeMultiplicationPrompt() {
      let a;
      let b;
      if (state.difficulty === "single") {
        a = randInt(2, 12);
        b = randInt(2, 12);
      } else if (state.difficulty === "double") {
        a = randInt(10, 99);
        b = randInt(2, 9);
      } else {
        a = randInt(100, 999);
        b = randInt(2, 9);
      }
      return { kind: "math", answer: a * b, text: `${formatNumber(a)} x ${formatNumber(b)}` };
    }

    function makeDivisionPrompt() {
      let divisor;
      let quotient;
      let dividend;
      if (state.difficulty === "single") {
        divisor = randInt(2, 12);
        quotient = randInt(2, 12);
      } else if (state.difficulty === "double") {
        divisor = randInt(2, 9);
        quotient = randInt(5, 45);
      } else {
        divisor = randInt(2, 9);
        quotient = randInt(20, 111);
      }
      dividend = divisor * quotient;
      if (state.difficulty === "double") {
        while (dividend < 10 || dividend > 99) {
          divisor = randInt(2, 9);
          quotient = randInt(5, 45);
          dividend = divisor * quotient;
        }
      } else if (state.difficulty === "multi") {
        while (dividend < 100 || dividend > 999) {
          divisor = randInt(2, 9);
          quotient = randInt(20, 111);
          dividend = divisor * quotient;
        }
      }
      return { kind: "math", answer: quotient, text: `${formatNumber(dividend)} ÷ ${divisor}` };
    }

    function makeRoundingPrompt() {
      const minWithin = state.roundingNearest * 10;
      if (state.roundingWithin < minWithin) {
        state.roundingWithin = ROUNDING_WITHIN_OPTIONS.find((value) => value >= minWithin) || 100000;
      }
      const number = randInt(Math.min(state.roundingNearest, state.roundingWithin - 1), state.roundingWithin - 1);
      const rounded = Math.round(number / state.roundingNearest) * state.roundingNearest;
      return {
        kind: "rounding",
        answer: rounded,
        number: formatNumber(number),
        place: formatNumber(state.roundingNearest),
        text: `${formatNumber(rounded)}`
      };
    }

    function makeCountingPrompt() {
      const limit = state.difficulty === "single" ? 20 : state.difficulty === "double" ? 50 : 100;
      const style = state.countingStyle === "mixed" ? choose(["forward", "backward", "missing"]) : state.countingStyle;
      let sequence;
      let answer;
      if (style === "forward") {
        const start = randInt(0, Math.max(0, limit - 3));
        sequence = [start, start + 1, start + 2, null];
        answer = start + 3;
      } else if (style === "backward") {
        const start = randInt(3, limit);
        sequence = [start, start - 1, start - 2, null];
        answer = start - 3;
      } else {
        const dir = choose(["forward", "backward"]);
        const start = dir === "forward" ? randInt(0, Math.max(0, limit - 2)) : randInt(2, limit);
        const base = dir === "forward" ? [start, start + 1, start + 2] : [start, start - 1, start - 2];
        const blankIndex = randInt(0, 2);
        answer = base[blankIndex];
        sequence = base.map((num, idx) => (idx === blankIndex ? null : num));
      }
      const sequenceHtml = sequence
        .map((item) => item === null ? '<span class="blank">&nbsp;&nbsp;&nbsp;</span>' : htmlEscape(formatNumber(item)))
        .join(", ");
      return { kind: "counting", answer, sequenceHtml, text: formatNumber(answer) };
    }

    function makeTenFramePrompt() {
      let total;
      if (state.difficulty === "single") total = randInt(1, 10);
      else if (state.difficulty === "double") total = randInt(11, 20);
      else total = randInt(21, 40);
      return { kind: "tenframes", answer: total, total };
    }

    function makeTellingTimePrompt() {
      const hour = randInt(1, 12);
      let minute;
      if (state.difficulty === "single") minute = choose([0, 30]);
      else if (state.difficulty === "double") minute = randInt(0, 11) * 5;
      else minute = randInt(0, 59);
      const answer = `${hour}:${String(minute).padStart(2, "0")}`;
      return { kind: "tellingtime", answer, hour, minute };
    }

    function makeMathPromptByOp(op) {
      if (op === "addition") return makeAdditionPrompt();
      if (op === "subtraction") return makeSubtractionPrompt();
      if (op === "multiplication") return makeMultiplicationPrompt();
      if (op === "division") return makeDivisionPrompt();
      if (op === "rounding") return makeRoundingPrompt();
      if (op === "counting") return makeCountingPrompt();
      if (op === "tellingtime") return makeTellingTimePrompt();
      if (op === "tenframes") return makeTenFramePrompt();
      return makeCoinPrompt();
    }

    function toMathPair(prompt) {
      const pairId = nextPromptId("m");
      if (prompt.kind === "math") {
        return {
          id: pairId,
          source: "math",
          prompt: { kind: "math-expression", text: prompt.text },
          answer: { kind: "text", text: formatNumber(prompt.answer) }
        };
      }
      if (prompt.kind === "rounding") {
        return {
          id: pairId,
          source: "math",
          prompt: { kind: "math-rounding", number: prompt.number, place: prompt.place },
          answer: { kind: "text", text: prompt.text }
        };
      }
      if (prompt.kind === "counting") {
        return {
          id: pairId,
          source: "math",
          prompt: { kind: "math-counting", sequenceHtml: prompt.sequenceHtml },
          answer: { kind: "text", text: formatNumber(prompt.answer) }
        };
      }
      if (prompt.kind === "tenframes") {
        return {
          id: pairId,
          source: "math",
          prompt: { kind: "math-tenframe", total: prompt.total },
          answer: { kind: "text", text: formatNumber(prompt.answer) }
        };
      }
      if (prompt.kind === "tellingtime") {
        return {
          id: pairId,
          source: "math",
          prompt: { kind: "math-time", hour: prompt.hour, minute: prompt.minute },
          answer: { kind: "text", text: prompt.answer }
        };
      }
      return {
        id: pairId,
        source: "math",
        prompt: { kind: "math-coins", coins: prompt.coins },
        answer: { kind: "text", text: `${prompt.answer}c` }
      };
    }

    function buildMathPairs(count) {
      const ops = Array.from(state.mathOperations);
      const pool = ops.length ? ops : ["addition"];
      const pairs = [];
      const seen = new Set();
      let cursor = 0;

      while (pairs.length < count) {
        const op = pool[cursor % pool.length];
        cursor += 1;
        let made = null;
        for (let tries = 0; tries < 24; tries += 1) {
          const prompt = makeMathPromptByOp(op);
          const key = `${op}:${prompt.kind}:${prompt.answer != null ? String(prompt.answer) : JSON.stringify(prompt)}`;
          if (!seen.has(key) || tries > 12) {
            seen.add(key);
            made = toMathPair(prompt);
            break;
          }
        }
        if (made) pairs.push(made);
      }
      return pairs;
    }

    function toReadingPair(word, imageSrc) {
      const pairId = nextPromptId("r");
      if (state.readingPairType === "word-word") {
        return {
          id: pairId,
          source: "reading",
          prompt: { kind: "text", text: word },
          answer: { kind: "text", text: word }
        };
      }
      const promptAsImage = Math.random() < 0.5;
      if (promptAsImage) {
        return {
          id: pairId,
          source: "reading",
          prompt: { kind: "reading-image", word, src: imageSrc },
          answer: { kind: "text", text: word }
        };
      }
      return {
        id: pairId,
        source: "reading",
        prompt: { kind: "text", text: word },
        answer: { kind: "reading-image", word, src: imageSrc }
      };
    }

    function buildReadingPairs(count) {
      const pool = buildReadingWordPool();
      if (!pool.length) return [];

      if (state.readingPairType === "picture-word") {
        const candidates = uniqueByLowercase(pool)
          .map((word) => ({ word, src: resolveWordImage(word) }))
          .filter((item) => item.src);
        if (!candidates.length) return [];
        const picked = fillToN(shuffle(candidates), count);
        return picked.map((item) => toReadingPair(item.word, item.src));
      }

      const picked = fillToN(shuffle(pool), count);
      return picked.map((word) => toReadingPair(word, resolveWordImage(word)));
    }

    function createCardsFromPairs(pairs) {
      const cards = [];
      pairs.forEach((pair) => {
        cards.push({
          id: `${pair.id}-p`,
          pairId: pair.id,
          side: "prompt",
          content: pair.prompt,
          source: pair.source,
          matched: false
        });
        cards.push({
          id: `${pair.id}-a`,
          pairId: pair.id,
          side: "answer",
          content: pair.answer,
          source: pair.source,
          matched: false
        });
      });
      return shuffle(cards);
    }

    function startTimer() {
      stopTimer();
      state.startedAtMs = Date.now();
      state.elapsedSeconds = 0;
      state.timerId = window.setInterval(() => {
        state.elapsedSeconds = Math.floor((Date.now() - state.startedAtMs) / 1000);
        renderScoreboard();
      }, 1000);
    }

    function stopTimer() {
      if (state.timerId) {
        window.clearInterval(state.timerId);
        state.timerId = null;
      }
    }

    function resetRoundState() {
      state.revealed = [];
      state.matchedCount = 0;
      state.locked = false;
      state.boardComplete = false;
      state.turnCount = 0;
      state.mismatchCount = 0;
      state.teamScores = [0, 0, 0, 0];
      state.currentTeam = 0;
      winBanner.classList.add("hidden");
      winBanner.textContent = "";
    }

    function maybeFinishGame() {
      if (state.matchedCount < state.pairCount) return;
      state.boardComplete = true;
      stopTimer();
      state.elapsedSeconds = Math.floor((Date.now() - state.startedAtMs) / 1000);
      renderScoreboard();

      if (state.playMode === "solo") {
        winBanner.textContent = `Board Complete! Time ${timeLabel(state.elapsedSeconds)} | Turns ${state.turnCount} | Misses ${state.mismatchCount}`;
      } else {
        const scores = state.teamScores.slice(0, state.teamCount);
        const best = Math.max(...scores);
        const winners = scores
          .map((score, idx) => ({ score, idx }))
          .filter((x) => x.score === best)
          .map((x) => `Team ${x.idx + 1}`);
        winBanner.textContent = winners.length === 1
          ? `${winners[0]} wins with ${best} pairs! (${timeLabel(state.elapsedSeconds)})`
          : `Tie: ${winners.join(" and ")} with ${best} pairs each.`;
      }
      winBanner.classList.remove("hidden");
      setStatus("Round complete. Start a new board to play again.");
    }

    function handleCardClick(index) {
      if (state.locked || state.boardComplete) return;
      const card = state.cards[index];
      if (!card || card.matched) return;
      if (state.revealed.includes(index)) return;

      state.revealed.push(index);
      renderBoard();

      if (state.revealed.length < 2) return;

      state.locked = true;
      state.turnCount += 1;
      const [i1, i2] = state.revealed;
      const c1 = state.cards[i1];
      const c2 = state.cards[i2];
      const isMatch = c1 && c2 && c1.pairId === c2.pairId;

      if (isMatch) {
        window.setTimeout(() => {
          c1.matched = true;
          c2.matched = true;
          state.revealed = [];
          state.locked = false;
          state.matchedCount += 1;
          if (state.playMode === "teams") {
            state.teamScores[state.currentTeam] += 1;
            setStatus(`Team ${state.currentTeam + 1} found a match and keeps the turn.`);
          } else {
            setStatus("Match found!");
          }
          renderScoreboard();
          renderBoard();
          maybeFinishGame();
        }, 480);
      } else {
        if (state.playMode === "solo") {
          state.mismatchCount += 1;
        } else {
          state.currentTeam = (state.currentTeam + 1) % state.teamCount;
          setStatus(`No match. Team ${state.currentTeam + 1}'s turn.`);
        }
        window.setTimeout(() => {
          state.revealed = [];
          state.locked = false;
          renderScoreboard();
          renderBoard();
        }, 780);
      }
    }

    async function buildPairsForCurrentSettings() {
      const total = state.pairCount;
      if (state.deckType === "reading" || state.deckType === "mixed") {
        await ensureImageIndexLoaded();
      }

      const out = [];
      if (state.deckType === "math") {
        out.push(...buildMathPairs(total));
      } else if (state.deckType === "reading") {
        out.push(...buildReadingPairs(total));
      } else {
        const mathCount = Math.ceil(total / 2);
        const readingCount = total - mathCount;
        out.push(...buildMathPairs(mathCount));
        out.push(...buildReadingPairs(readingCount));
        if (out.length < total) {
          out.push(...buildMathPairs(total - out.length));
        }
      }
      return out.slice(0, total);
    }

    async function startNewBoard() {
      const hasMath = state.deckType === "math" || state.deckType === "mixed";
      const hasReading = state.deckType === "reading" || state.deckType === "mixed";
      if (hasMath && !state.mathOperations.size) {
        window.alert("Select at least one math operation.");
        return;
      }
      if (hasReading && !state.selectedSkills.size) {
        window.alert("Select at least one reading skill.");
        return;
      }

      stopTimer();
      btnStart.disabled = true;
      setStatus("Building board...");
      try {
        const pairs = await buildPairsForCurrentSettings();
        if (pairs.length < state.pairCount) {
          if (state.deckType === "reading" && state.readingPairType === "picture-word") {
            window.alert("Not enough words with images for those reading skills. Add more skills or switch pair type.");
          } else {
            window.alert("Not enough content found for these settings. Try adding skills or changing deck type.");
          }
          setStatus("Unable to build board. Update settings and try again.");
          return;
        }
        resetRoundState();
        state.cards = createCardsFromPairs(pairs);
        renderScoreboard();
        renderBoard();
        startTimer();
        setStatus("Board ready. Flip two cards to find each match.");
      } finally {
        btnStart.disabled = false;
      }
    }

    function shuffleBoard() {
      if (!state.cards.length) return;
      if (state.locked || state.boardComplete) return;
      state.revealed = [];
      state.cards = shuffle(state.cards);
      renderBoard();
      setStatus("Board shuffled.");
    }

    function resetScoreOnly() {
      stopTimer();
      state.elapsedSeconds = 0;
      state.turnCount = 0;
      state.mismatchCount = 0;
      state.teamScores = [0, 0, 0, 0];
      state.currentTeam = 0;
      renderScoreboard();
      setStatus("Score reset.");
    }

    function syncStateFromControls() {
      state.teamCount = Math.max(2, Math.min(4, Number(teamCountSelect.value) || 2));
      state.pairCount = Math.max(6, Math.min(12, Number(pairCountSelect.value) || 8));
      state.difficulty = mathDifficultySelect.value;
      state.regroupMode = regroupSelect.value;
      state.roundingStyle = roundingStyleSelect.value;
      state.roundingNearest = Number(roundingNearestSelect.value) || 10;
      state.roundingWithin = Number(roundingWithinSelect.value) || 100;
      state.countingStyle = countingStyleSelect.value;
    }

    function setSelectedPills(row, attr, value) {
      row.querySelectorAll(".pill").forEach((pill) => {
        pill.classList.toggle("selected", pill.getAttribute(attr) === value);
      });
    }

    deckTypeRow.querySelectorAll(".pill").forEach((button) => {
      button.addEventListener("click", () => {
        state.deckType = button.dataset.deck || "math";
        setSelectedPills(deckTypeRow, "data-deck", state.deckType);
        updateVisibility();
      });
    });

    playModeRow.querySelectorAll(".pill").forEach((button) => {
      button.addEventListener("click", () => {
        state.playMode = button.dataset.play || "solo";
        setSelectedPills(playModeRow, "data-play", state.playMode);
        updateVisibility();
        renderScoreboard();
      });
    });

    mathOpsRow.querySelectorAll(".pill").forEach((button) => {
      button.addEventListener("click", () => {
        const op = button.dataset.op;
        if (!op) return;
        if (state.mathOperations.has(op)) {
          state.mathOperations.delete(op);
          button.classList.remove("selected");
        } else {
          state.mathOperations.add(op);
          button.classList.add("selected");
        }
        if (!state.mathOperations.size) {
          state.mathOperations.add("addition");
          const addBtn = mathOpsRow.querySelector('.pill[data-op="addition"]');
          if (addBtn) addBtn.classList.add("selected");
        }
      });
    });

    blendRow.querySelectorAll(".pill").forEach((button) => {
      button.addEventListener("click", () => {
        state.includeBlends = button.dataset.blends === "yes";
        setSelectedPills(blendRow, "data-blends", state.includeBlends ? "yes" : "no");
      });
    });

    readingPairTypeRow.querySelectorAll(".pill").forEach((button) => {
      button.addEventListener("click", () => {
        state.readingPairType = button.dataset.rpair || "picture-word";
        setSelectedPills(readingPairTypeRow, "data-rpair", state.readingPairType);
      });
    });

    teamCountSelect.addEventListener("change", syncStateFromControls);
    pairCountSelect.addEventListener("change", syncStateFromControls);
    mathDifficultySelect.addEventListener("change", syncStateFromControls);
    regroupSelect.addEventListener("change", syncStateFromControls);
    roundingStyleSelect.addEventListener("change", syncStateFromControls);
    roundingNearestSelect.addEventListener("change", syncStateFromControls);
    roundingWithinSelect.addEventListener("change", syncStateFromControls);
    countingStyleSelect.addEventListener("change", syncStateFromControls);

    btnStart.addEventListener("click", async () => {
      syncStateFromControls();
      await startNewBoard();
    });

    btnShuffle.addEventListener("click", () => {
      shuffleBoard();
    });

    btnFullscreen.addEventListener("click", async () => {
      if (!fullscreenSupported()) return;
      try {
        if (getFullscreenElement() === boardShell) {
          await exitDocumentFullscreen();
        } else {
          await requestElementFullscreen(boardShell);
        }
      } catch (_) {
      } finally {
        updateFullscreenButton();
      }
    });

    btnResetScore.addEventListener("click", () => {
      resetScoreOnly();
    });

    document.addEventListener("fullscreenchange", updateFullscreenButton);
    document.addEventListener("webkitfullscreenchange", updateFullscreenButton);
    window.addEventListener("resize", applyBoardLayout);

    renderSkills();
    updateSkillLabel();
    updateVisibility();
    renderScoreboard();
    renderBoard();
    updateFullscreenButton();
  </script>
</body>
</html>
