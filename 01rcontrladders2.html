<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>R-Controlled Word Ladders</title>

  <!-- Uses rladders.js which exposes window.RCTRL_NS -->
  <script src="rladders.js" defer></script>
  <script src="ladder_image_fallback.js" defer></script>

  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">

  <style>
    @font-face { font-family: 'BoxesFont'; src: url('fonts/boxes2.otf') format('opentype'); }
    @font-face { font-family: 'UnderlineFont'; src: url('fonts/underlines.otf') format('opentype'); }

    :root{ --ink:#1f365f; --bg:#ffffff; --card:#f6f9ff; --card2:#fff7f0; --border:#cfd7ef; --border2:#f2d8bd; }
    body { font-family:'Poppins',sans-serif; margin:10px; text-align:center; color:var(--ink); background:var(--bg); }
    h1 { font-size:32px; margin-bottom:6px; }
    .subtitle { font-size:16px; margin-bottom:8px; }
    button { font-size:16px; padding:6px 10px; margin:6px; cursor:pointer; }
    label { margin:0 6px; font-size:18px; }
    .pattern { font-size:100px; line-height:1; margin-top:4px; letter-spacing:0; }
    #copyright { font-size:12px; text-align:right; width:100%; }
    .card { display:inline-block; text-align:center; background:var(--card); border:2px solid var(--border); border-radius:14px; padding:14px 18px; margin:10px auto; font-size:18px; }
    .card.alt { background:var(--card2); border-color:var(--border2); }
    .card h2 { margin:0 0 8px; font-size:20px; }
    .controls { display:flex; justify-content:center; align-items:center; gap:16px; flex-wrap:wrap; font-size:18px; }
    .screenOnly { display:block; font-size:18px; }

    @media print{
      body *{ visibility:hidden; }
      #ladderOutput, #ladderOutput *{ visibility:visible; }
      #ladderOutput{ position:absolute; top:0; left:0; width:100%; margin:0; padding:10px; box-sizing:border-box; }
      .screenOnly{ display:none !important; }
      #ladderOutput br{ display:none !important; }
      @page { margin:0.5in; }
    }
  </style>
</head>
<body>
  <h1>R-Controlled Word Ladders</h1>

  <div class="screenOnly" style="max-width:920px;margin:0 auto 12px;">
    <strong>Directions:</strong>
    Choose <em>No Blends</em>, <em>Include Blends</em>, or <em>Only Blends</em>. Then generate and print.
  </div>

  <div class="card">
    <h2>Format</h2>
    <div class="controls">
      <label><input type="radio" name="ladderMode" value="No Blends" checked> 1. No Blends</label>
      <label><input type="radio" name="ladderMode" value="Include Blends"> 2. Include Blends</label>
      <label><input type="radio" name="ladderMode" value="Only Blends"> 3. Only Blends</label>
    </div>
  </div>

  <div class="card alt">
    <h2>Display</h2>
    <div class="controls">
      <label><input type="radio" name="cellStyle" value="elkonin" checked> Elkonin Boxes</label>
      <label><input type="radio" name="cellStyle" value="underlines"> Underlines</label>
      <label><input type="checkbox" id="boldChanged" checked> Bold Changed Part</label>
    </div>
  </div>

  <div style="margin:8px 0 10px;">
     <center><img src="images/chrome.png"></center>
    <button id="btnGenerate">Generate Ladder</button>
    <button onclick="window.print()">Print Page</button>
  </div>

  <div id="ladderOutput" style="margin-top:8px; margin-bottom:60px;"></div>

  <script>
    /* ======= helpers that use RCTRL_NS ======= */
    const NS = () => (window && window.RCTRL_NS) ? window.RCTRL_NS : null;

    function getPattern(word){
      const dict = NS()?.patterns?.() || {};
      return dict[(word||'').toLowerCase()] || '111';
    }
    function getImage(word){
      const dict = NS()?.images?.() || {};
      return dict[(word||'').toLowerCase()] || 'images/placeholder_110.png';
    }
    function splitByPattern(word, pattern){
      const chunks=[]; let i=0;
      for (let j=0;j<pattern.length;j++){
        const d=pattern[j], len=(d==='3')?3:(d==='2')?2:1;
        chunks.push(word.slice(i,i+len)); i+=len;
      }
      return chunks;
    }
    function arraysEqual(a,b){ return a.length===b.length && a.every((v,i)=>v===b[i]); }

    function getStepChange(prevWord, word, prevPat, pat){
      if (!prevWord) return null;
      const A=splitByPattern(prevWord, prevPat);
      const B=splitByPattern(word, pat);

      if (A.length===B.length){
        const changed = [];
        for (let i=0;i<A.length;i++){
          if ((A[i]||'')!==(B[i]||'')){ changed.push(i); }
        }
        if (changed.length !== 1) return null;
        const idx = changed[0];
        const from = A[idx] || "";
        const to = B[idx] || "";

        if (to.length === from.length + 1 && (to.startsWith(from) || to.endsWith(from))) {
          const added = to.startsWith(from) ? to.slice(-1) : to.slice(0, to.length - from.length);
          const atEnd = to.startsWith(from);
          return { kind: "add_letter", index: idx, from, to, added, atEnd };
        }
        if (from.length === to.length + 1 && (from.startsWith(to) || from.endsWith(to))) {
          const removed = from.startsWith(to) ? from.slice(-1) : from.slice(0, from.length - to.length);
          const atEnd = from.startsWith(to);
          return { kind: "remove_letter", index: idx, from, to, removed, atEnd };
        }

        return { kind: "replace", index: idx, from, to };
      }
      if (B.length===A.length+1){
        for (let i=0;i<B.length;i++){
          const test=B.slice(0,i).concat(B.slice(i+1));
          if (arraysEqual(A,test)) return { kind: "add_chunk", index: i, from: "", to: B[i] || "" };
        }
      }
      if (A.length===B.length+1){
        for (let i=0;i<A.length;i++){
          const test=A.slice(0,i).concat(A.slice(i+1));
          if (arraysEqual(B,test)) return { kind: "remove_chunk", index: i, from: A[i] || "", to: "" };
        }
      }
      return null;
    }

    function getHintFromStep(step, prevWord, word){
      if (!step) return `${prevWord} → ${word}`;
      if (step.kind === "add_letter") {
        const micro = step.atEnd
          ? `${step.from} → ${step.from}<b>${step.added}</b>`
          : `${step.from} → <b>${step.added}</b>${step.from}`;
        return `+ ${step.added} <span style="font-size:16px;opacity:.8;margin-left:8px;">${micro}</span>`;
      }
      if (step.kind === "remove_letter") {
        const micro = step.atEnd
          ? `${step.from.slice(0,-1)}<b>${step.removed}</b> → ${step.to}`
          : `<b>${step.removed}</b>${step.from.slice(1)} → ${step.to}`;
        return `- ${step.removed} <span style="font-size:16px;opacity:.8;margin-left:8px;">${micro}</span>`;
      }
      if (step.kind === "add_chunk") return `+ ${step.to}`;
      if (step.kind === "remove_chunk") return `- ${step.from}`;
      if (step.kind === "replace") return `${step.from} → ${step.to}`;
      return `${prevWord} → ${word}`;
    }

    function isValidLadder(ladder){
      if (!Array.isArray(ladder) || ladder.length < 2) return false;
      for (let i = 1; i < ladder.length; i++) {
        const prev = ladder[i - 1] || "";
        const word = ladder[i] || "";
        const prevP = getPattern(prev);
        const patt = getPattern(word);
        if (!getStepChange(prev, word, prevP, patt)) return false;
      }
      return true;
    }

    function generateLadder(){
      const api = NS();
      if (!api){
        alert('❌ R-controlled data not loaded. Check rladders.js path/name.');
        return;
      }
      const mode = document.querySelector('input[name="ladderMode"]:checked').value; // "No Blends" | "Include Blends" | "Only Blends"
      const ladders = api.getLaddersByMode(mode).filter(isValidLadder);
      if (!Array.isArray(ladders) || !ladders.length){
        alert(mode==='Only Blends' ? '❌ No valid one-change r-controlled blend ladders found.' : '❌ No valid one-change r-controlled ladders available.');
        return;
      }

      const cellStyle = document.querySelector('input[name="cellStyle"]:checked').value;
      const useFont   = (cellStyle==='underlines') ? 'UnderlineFont' : 'BoxesFont';
      const boldChanged = document.getElementById('boldChanged').checked;

      const ladder = ladders[Math.floor(Math.random()*ladders.length)];
      const rows = ladder.map((word, i)=>{
        const first = (i===0), last=(i===ladder.length-1);
        const prev  = ladder[i-1] || '';
        const patt  = getPattern(word);
        const prevP = getPattern(prev);
        const imgSrc= getImage(word);
        const resolvedImgSrc = window.ladderImageFallback
          ? window.ladderImageFallback.ensureSrc(imgSrc, word)
          : imgSrc;

        let patternHTML = '';
        if (!first){
          const step = getStepChange(prev, word, prevP, patt);
          const changedIdx = (boldChanged && step) ? step.index : -1;
          patternHTML = Array.from(patt).map((ch,idx)=> idx===changedIdx ? `<span style="font-weight:700;">${ch}</span>` : ch).join('');
        }

        const display = first
          ? `<div style="font-size:32px;font-weight:600;letter-spacing:2px;font-family:'Poppins',sans-serif;">${word}</div>`
          : `<div class="pattern" style="font-family:'${useFont}',monospace;font-size:${useFont==='UnderlineFont'?'85px':'100px'};">${patternHTML}</div>`;

        const imgTD = `<td style="padding:5px 7px;width:140px;"><img src="${resolvedImgSrc}" alt="${word}" data-word="${word}" onerror="window.ladderImageFallback && window.ladderImageFallback.handleError(this,this.dataset.word)" style="width:110px;height:110px;object-fit:contain;"></td>`;
        const borders = !last ? 'border-bottom:4px solid #000;border-left:4px solid #000;border-right:4px solid #000;' : 'border-left:4px solid #000;border-right:4px solid #000;';
        const wordTD = `<td style="padding:5px 7px;${borders}">${display}</td>`;

        const hintTD = first
          ? `<td style="padding:3px 5px;width:170px;"></td>`
          : `<td style="padding:3px 5px;width:170px;">
               <div style="display:flex;justify-content:center;align-items:center;background:#f0f0f0;border:3px solid #000;border-radius:12px;padding:6px 10px;font-size:22px;text-align:center;">
                 ${getHintFromStep(getStepChange(prev, word, prevP, patt), prev, word)}
               </div>
             </td>`;

        return `<tr>${imgTD}${wordTD}${hintTD}</tr>`;
      }).join('');

      const titleSuffix = (mode==='Include Blends') ? ' — Include Blends' : (mode==='Only Blends') ? ' — Only Blends' : '';
      const html = `
        <div style="display:flex;flex-direction:column;align-items:center;width:98%;margin:0 auto;">
          <div id="titleBlock" style="text-align:center;">
            <h2 style="font-size:24px;">R-Controlled Word Ladders${titleSuffix}</h2>
            <p style="font-size:12px;"><strong>Directions:</strong> Start at the top of the ladder and spell the correct words.</p>
          </div>
          <table style="border-collapse:collapse;margin:0 auto;width:100%;max-width:600px;">
            ${rows}
          </table>
          <br><br>
          <div id="copyright">Copyright - InterventionStation.com - @TeachwithMrC</div>
        </div>`;
      document.getElementById('ladderOutput').innerHTML = html;
    }

    document.getElementById('btnGenerate').addEventListener('click', generateLadder);
  </script>
</body>
</html>
