<script>
  let selectedSkills = new Set();
  let includeBlends = null;

  document.querySelectorAll('.skill-button').forEach(btn => {
    btn.addEventListener('click', () => {
      const skill = btn.dataset.skill;
      if (selectedSkills.has(skill)) {
        selectedSkills.delete(skill);
        btn.classList.remove('selected');
      } else {
        selectedSkills.add(skill);
        btn.classList.add('selected');
      }
      document.getElementById('selected-skills').innerText = Array.from(selectedSkills).join(', ');
    });
  });

  document.getElementById('includeBlendsYes').addEventListener('click', function () {
    includeBlends = true;
    this.classList.add('selected');
    document.getElementById('includeBlendsNo').classList.remove('selected');
  });
  document.getElementById('includeBlendsNo').addEventListener('click', function () {
    includeBlends = false;
    this.classList.add('selected');
    document.getElementById('includeBlendsYes').classList.remove('selected');
  });

  /** ✅ Generate Page */
  function generatePage() {
    if (selectedSkills.size === 0) return alert("Select at least one skill!");
    if (includeBlends === null) return alert("Please choose Include Blends: Yes or No");

    const source = soundBoxWords;
    const blends = includeBlends;
    let allWords = [];

    selectedSkills.forEach(skill => {
      allWords = allWords.concat(getWordsForSkill(skill, source, blends));
    });

    // ✅ Remove duplicate words
    allWords = allWords.filter((item, idx, self) =>
      idx === self.findIndex(w => w.word === item.word)
    );

    if (allWords.length === 0) return alert("No words found for the selected skills.");

    // ✅ Ensure at least 8 words
    while (allWords.length < 8) allWords = allWords.concat(allWords);
    allWords = shuffle(allWords).slice(0, 8);

    const output = document.getElementById('output');
    output.innerHTML = '';

    const title = document.createElement('div');
    title.className = 'worksheet-title';
    title.textContent = `${Array.from(selectedSkills).join(', ')} Word Mapping`;

    const directions = document.createElement('div');
    directions.className = 'worksheet-directions';
    directions.textContent = "Read each word, write it in the sound boxes correctly, read it again.";

    output.appendChild(title);
    output.appendChild(directions);

    const table = document.createElement('table');
    table.className = 'word-table';
    for (let r = 0; r < 4; r++) {
      const tr = document.createElement('tr');
      for (let c = 0; c < 2; c++) {
        const td = document.createElement('td');
        const idx = r * 2 + c;
        if (idx < allWords.length) {
          td.innerHTML = `
            <div class="word" style="margin-bottom:10px;">${allWords[idx].word}</div>
            <div class="pattern" style="font-size:70px; line-height:1.1; display:block;">
              ${allWords[idx].pattern}
            </div>
          `;
        }
        tr.appendChild(td);
      }
      table.appendChild(tr);
    }
    output.appendChild(table);
  }

  /** ✅ Unified skill fetch with Blend fallback */
  function getWordsForSkill(skill, source, blends) {
    const blendSuffixes = [" with Blends", " with Digraphs and Blends"];
    const glueNgParts = ["ang", "ing", "ong", "ung"];
    const glueNkParts = ["ank", "ink", "onk", "unk"];

    function fetchSet(base) {
      let result = [];
      if (blends) {
        blendSuffixes.forEach(suffix => {
          const key = `${base}${suffix}`;
          if (source[key]) result = result.concat(source[key]);
        });

        // ✅ Fallback if we have fewer than 8 unique words
        const uniqueCount = new Set(result.map(w => w.word)).size;
        if (uniqueCount < 8 && source[base]) {
          result = result.concat(source[base]);
        }
      } else {
        result = source[base] || [];
      }
      return result;
    }

    switch (skill) {
      // Short vowels
      case "Short A": return fetchSet("Short A");
      case "Short E": return fetchSet("Short E");
      case "Short I": return fetchSet("Short I");
      case "Short O": return fetchSet("Short O");
      case "Short U": return fetchSet("Short U");
      case "Mixed CVC":
        return [].concat(
          fetchSet("Short A"), fetchSet("Short E"),
          fetchSet("Short I"), fetchSet("Short O"), fetchSet("Short U")
        );

      // Digraphs
      case "Digraph(ck)": return fetchSet("Digraph(ck)");
      case "Digraph(sh)": return fetchSet("Digraph(sh)");
      case "Digraph(th)": return fetchSet("Digraph(th)");
      case "Digraph(ch)": return fetchSet("Digraph(ch)");
      case "Digraph(wh)": return fetchSet("Digraph(wh)");
      case "Digraphs Mixed":
        return [].concat(
          fetchSet("Digraph(ck)"), fetchSet("Digraph(sh)"),
          fetchSet("Digraph(th)"), fetchSet("Digraph(ch)"), fetchSet("Digraph(wh)")
        );

      // Glued
      case "Glued(all)": return fetchSet("Glued(all)");
      case "Glued(-ng)": return glueNgParts.flatMap(p => fetchSet(`Glued(${p})`));
      case "Glued(-nk)": return glueNkParts.flatMap(p => fetchSet(`Glued(${p})`));
      case "Glued Mixed":
        return [].concat(
          fetchSet("Glued(all)"),
          glueNgParts.flatMap(p => fetchSet(`Glued(${p})`)),
          glueNkParts.flatMap(p => fetchSet(`Glued(${p})`))
        );

      // VCe
      case "VCe(a_e)": return fetchSet("VCe(a_e)");
      case "VCe(i_e)": return fetchSet("VCe(i_e)");
      case "VCe(o_e)": return fetchSet("VCe(o_e)");
      case "VCe(u_e)": return fetchSet("VCe(u_e)");
      case "Mixed VCe":
        return [].concat(
          fetchSet("VCe(a_e)"), fetchSet("VCe(i_e)"),
          fetchSet("VCe(o_e)"), fetchSet("VCe(u_e)")
        );

      // R-Controlled
      case "R-Controlled(ar)": return fetchSet("R-Controlled(ar)");
      case "R-Controlled(or)": return fetchSet("R-Controlled(or)");
      case "R-Controlled(er,ir,ur)": return fetchSet("R-Controlled(er,ir,ur)");
      case "Mixed R-Controlled":
        return [].concat(
          fetchSet("R-Controlled(ar)"), fetchSet("R-Controlled(or)"), fetchSet("R-Controlled(er,ir,ur)")
        );

      // Vowel Teams
      case "Long A": return fetchSet("Long A");
      case "Long E": return fetchSet("Long E");
      case "Long I": return fetchSet("Long I");
      case "Long O": return fetchSet("Long O");
      case "Long U": return fetchSet("Long U");
      case "Mixed Vowel Teams":
        return [].concat(
          fetchSet("Long A"), fetchSet("Long E"),
          fetchSet("Long I"), fetchSet("Long O"), fetchSet("Long U")
        );

      // Diphthongs
      case "oy/oi": return fetchSet("oy/oi");
      case "ow/ou": return fetchSet("ow/ou");

      // Variant Vowels
      case "au/aw": return fetchSet("au/aw");
      case "oo": return fetchSet("oo");

      // Soft C & G
      case "-ge": return fetchSet("Soft G(ge)");
       case "-ce": return fetchSet("Soft C(ce)");  
         case "-dge": return fetchSet("Soft G(dge)");

      default: return fetchSet(skill);
    }
  }

  function shuffle(arr) { return [...arr].sort(() => Math.random() - 0.5); }
</script>
